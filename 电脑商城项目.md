#                                                  电脑商城项目

##  一、项目分析

1、项目功能：登陆，注册，热销商品，用户管理(密码，个人信息，头像，收货地址)，购物车(展示，增加，删除)，订单模块。

2、开发顺序：注册，登陆，用户管理，购物车，商品，订单模块。

3、某一个模块的开发：

- 持久层开发：依据前端页面的设置规划相关的SQL语句，及进行配置
- 业务层开发：核心的功能控制，业务操作以及异常的处理
- 控制层开发：接受请求，处理响应
- 前端开发：JS，Query，AJAX这次技术来连接后台

## 二、搭建项目

1、JDK：1.8版本及以上的版本

2、maven：配置到idea，3.6.1版本

3、数据库：MariaDB，MyQSL，要求是5.1及以上的版本

4、开发的平台：idea开发

## 三、搭建项目

1、项目名称：store，表示商城

2、结构：com.cy.store

```java
java web
myabits
mysqldriver
```

3、资源文件：resources文件夹下(static,templates)

4、单元测试:test.com.cy.store

5、在properties文件中配置数据库的连接源信息

```properties
spring.datasource.url=jdbc:mysql://localhost:3306/store?useUnicode=true&characterEncoding=utf-8&serverTimezone=Asia/Shanghai
spring.datasource.username=root
spring.datasource.password=root
spring.datasource.driver=com.mybatis.cj.jdbc.driver
mybatis.mapper-locations=classpath:mapper/*.xml
user.address.max-count=20
server.port=8081
spring.jackson.default-property-inclusion=NON_NULL
```

6、创建一个store数据库

```mysql
create database store character set utf8;
```

7、测试连接：

- 启动SpringBoot主类，是否有对应的spring图形输出
- 在单元测试类中测试数据库的连接是否可以正常加载

```java
    @Autowired
    private DataSource dataSource;
     @Test
     void getConnection() throws SQLException {
        System.out.println(dataSource.getConnection());}
```

8、访问项目的静态资源是否可以正常加载，所有的静态资源复制static目录下

注意：idea对于JS代码的兼容性比较差，编写js代码但是有的时候不能够正常去加载

1. idea缓存清理
2. clear-instal
3. rebuild重新构建
4. 重启idea和操作系统

## (一）用户注册

#### #1 创建数据表

1、选中数据表

```mysql
use store
```

2、创建t_user表:

```mysql
CREATE TABLE t_user (
	uid INT AUTO_INCREMENT COMMENT '用户id',
	username VARCHAR(20) NOT NULL UNIQUE COMMENT '用户名',
	password CHAR(32) NOT NULL COMMENT '密码',
	salt CHAR(36) COMMENT '盐值',
	phone VARCHAR(20) COMMENT '电话号码',
	email VARCHAR(30) COMMENT '电子邮箱',
	gender INT COMMENT '性别:0-女，1-男',
	avatar VARCHAR(50) COMMENT '头像',
	is_delete INT COMMENT '是否删除：0-未删除，1-已删除',
	created_user VARCHAR(20) COMMENT '日志-创建人',
	created_time DATETIME COMMENT '日志-创建时间',
	modified_user VARCHAR(20) COMMENT '日志-最后修改执行人',
	modified_time DATETIME COMMENT '日志-最后修改时间',
	PRIMARY KEY (uid)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
```

#### #2 创建用户的实体类

1、通过表的结构提取出表的公共字段，放在一个实体类的基类中，起名BaseEntity基类中

```java
package com.cy.store.entity;
//公共字段,实体类的基类
@Data
public class BaseEntity implements Serializable {
    private String createdUser;
    private Date createdTime;
    private String modifiedUser;
    private Date modifiedTime;
}
```

2、创建用户的实体类，需要继承BaseEntity基类

```java
package com.cy.store.entity;
/** 用户的实体类：SpringBoot约定大于配置*/
@Data
//@Component
public class User extends BaseEntity implements Serializable {
    private Integer uid;
    private String username;
    private String password;
    private String salt;
    private String phone;
    private String email;
    private String gender;
    private String avatar;
    private Integer isDelete;
  //get和set方法，equals和haseCode()方法，toString方法
}
```

#### #3 注册-持久层

###### 3.1 规划需要执行的SQL语句

1、用户的注册功能，相当于在做数据的插入操作

```mysql
insert into t_user (username ,password) values (值列表);
```

2、在用户的注册时首先去查询当前的用户名是否存在，如果存在则不能进行注册。相当于一条查询语句

```
select *from t_user where username=?;
```

###### 3.2 设计接口和抽象方法

1、定义Mapper接口，在项目的目录结构下首先创建一个mapper包，在这个包下再根据不同的功能模块来创建mapper接口。创建一个UserMapper的接口。要在接口中定义这两个SQL语句的抽象方法。

2、在启动类配置smapper接口文件的位置

```java
//MapperScan注解指定当前项目中的Mapper接口路径的位置，在项目启动的时候会加载所有的接口文件
@MapperScan("com.cy.store.mapper")
```

###### 3.3 编写映射

1、定义一个xml映射文件，于对应的接口相关联。所有的映射文件需要放置在resources目录下，在这个目录下创建一个mapper文件，然后在这个文件夹放Mapper的映射文件。

2、创建接口对应的映射文件，遵循和接口的名称保持一致即可。创建一个UserMapper.xml

```mysql
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<!--namespace属性：用于指定当前的映射文件和哪个接口进行映射，需要指定接口的文件路径，需要标注包的完整路径接口-->
<mapper namespace="com.cy.store.mapper.UserMapper">
    <!-- 自定义映射规则：resultMap标签完成映射规则的定义-->
    <!-- id属性: 表示给这个映射规则分配一个唯一的id值，对应的就是resultMap="id属性的值"属性的取值
         type属性: 取值是一个类，表示的是数据库的查询结果与Java哪个实体类进行结果集映射
    -->
    <resultMap id="UserEntityMap" type="com.cy.store.entity.User">
        <!-- 将表的字段和类的属性不一致的字段进行匹配指定，名称一致的字段可以省略不写-->
        <!-- 配合完成名称不一致的映射：
             column:表示表中的字段名称
             property：表示类中的属性名称
        -->
        <!-- 在定义映射规则时主键是不可以省略的-->
        <result column="uid" property="uid"></result>
        <result column="is_delete" property="isDelete"></result>
        <result column="created_user" property="createdUser"></result>
        <result column="created_time" property="createdTime"></result>
        <result column="modified_user" property="modifiedUser"></result>
        <result column="modified_time" property="modifiedTime"></result>
    </resultMap>
    <!-- id属性：表示映射的接口中方法的名称，直接在标签的内容里编写SQL语句-->
    <!--useGeneratedKeys属性: 表示开启欧哥字段的值递增
        keyProperty属性: 将表中的哪个字段作为主键进行递增-->
    <insert id="insert" useGeneratedKeys="true" keyProperty="uid">
        INSERT
        INTO t_user(
             username, password, salt, phone, email, gender, avatar, is_delete,
             created_user, created_time, modified_user, modified_time,
        )values(
        #{username},
        #{password},
        #{salt},
        #{phone},
        #{email},
        #{gender},
        #{avatar},
        #{isDelete},
        #{createdUser},
        #{createdTime},
        #{modifiedUser},
        #{modifiedTime}
        )
    </insert>

    <!-- select语句在执行的时候，查询的结果是一个对象，多个对象-->
    <!--
      resultType: 表示查询的结果集类型，只需要指定对应映射类型并且包含完整的包结构，resultType="com.cy.store.entity.UserMapper"
      resultMap: 表示当表的字段和类的对象属性的字段名称不一致时，来自定义查询结构集的映射规则    
    -->
    <select id="findByUsername" resultMap="UserEntityMap">
        select *
        from t_user
        where username = #{username}
    </select>


</mapper>
```

3、单元测试：每个独立的层编写完毕后需要编写单元测试方法，来测试当前的功能。

在test包结构下创建一个mapper的包，在这个包下面创建持久层的测试

```java
package com.cy.store.mapper;
//@SpringBootTest:表示当前的类是一个测试类，不会随同项目一块打包
@SpringBootTest
//@RunWith启动这个单元测试类(单元测试是不能运行的)，需要传递一个参数，必须是SpringRunner的实体类型
@RunWith(SpringRunner.class)
@SuppressWarnings({"all"})
public class UserMapperTest {
    //idea有检测功能，接口是不能直接创建Bean的(动态代理技术来解决)
    @Autowired
    private UserMapper userMapper;
    @Test
    public void insert() {
        User user = new User();
        user.setUsername("李华");
        user.setPassword("1234");
        Integer rows = userMapper.insert(user);
        System.out.println(rows);
    }
    @Test
    public void findByUsername() {
        User user = userMapper.findByUsername("tim");
        System.out.println(user);
    }
}
```

#### #4 注册-业务层

###### 4.1 规划异常

1、RuntimeException异常，作为异常的子类，然后在去定义具体的类型来继承这个异常。业务层异常的基类，ServiceExcption异常。这个异常来继承RuntimeExcption。异常机制的建立

```java
package com.cy.store.service.ex;
/**
 * 业务层异常的基类
 */
public class ServiceException extends RuntimeException {
    public ServiceException() {
        super();
    }
    public ServiceException(String message) {
        super(message);
    }
    //同时抛出异常的信息和对象
    public ServiceException(String message, Throwable cause) {
        super(message, cause);
    }
    public ServiceException(Throwable cause) {
        super(cause);
    }
    protected ServiceException(String message, Throwable cause, boolean enableSuppression, boolean writableStackTrace) {
        super(message, cause, enableSuppression, writableStackTrace);
    }
}
```

根据业务层不同的功能详细定义具体的异常的类型，统一的去继承ServiceException异常类。

2、用户在进行注册的时候，可能会产生用户名被占用的错误，抛出一个异常：UsernameDepulicatedException异常。

```java
package com.cy.store.service.ex;
/**
 * 用户名被占用的异常
 */
public class UsernameDuplicatedException extends ServiceException {
    public UsernameDuplicatedException() {
        super();
    }
    public UsernameDuplicatedException(String message) {
        super(message);
    }
    public UsernameDuplicatedException(String message, Throwable cause) {
        super(message, cause);
    }
    public UsernameDuplicatedException(Throwable cause) {
        super(cause);
    }
    protected UsernameDuplicatedException(String message, Throwable cause, boolean enableSuppression, boolean writableStackTrace) {
        super(message, cause, enableSuppression, writableStackTrace);
    }
}
```

3、正在执行插入的时候，服务器、数据库宕机。处理正在执行插入过程中所产生的异常InsertException异常

```java
package com.cy.store.service.ex;
/**数据在插入过程中所产生的异常*/
public class InsertException extends ServiceException{
    public InsertException() {
        super();
    }

    public InsertException(String message) {
        super(message);
    }

    public InsertException(String message, Throwable cause) {
        super(message, cause);
    }

    public InsertException(Throwable cause) {
        super(cause);
    }

    protected InsertException(String message, Throwable cause, boolean enableSuppression, boolean writableStackTrace) {
        super(message, cause, enableSuppression, writableStackTrace);
    }
}

```

###### 4.2 设计接口和抽象方法

在service包下创建一个IUserService接口。

```java
package com.cy.store.service;
/**
 * 用户模块业务层接口
 */
public interface IUserService {
    /**
     * 用户注册方法
     * @param user 用户的数据对象
     */
    void reg(User user);
}
```

2、创建一个实现类

```java
package com.cy.store.service.impl;
/**
 * 用户模块业务层的实现类
 */
@Service //将当前的对象交给Spring来管理，自动创建对象以及对象的维护
@SuppressWarnings({"all"})
public class UserServiceImpl implements IUserService {

    @Autowired
    private UserMapper userMapper;

    @Override
    public void reg(User user) {
        //通过user参数来获取传递过来的username
        String username = user.getUsername();
        //调用findByUsername(username)判断用户是否被注册过
        User result = userMapper.findByUsername(username);
        //判断结果集是否不为null则抛出用户名被占用的异常
        if (result != null) {
            //抛出异常
            throw new UsernameDuplicatedException("用户名被占用");
        }
        //密码加密处理的实现:md5算法的形式
        //(串+password+串)-----md5算法进行加密,连续加载三次
        //颜值+password+颜值----颜值就是一个随机的字符串
        String oldePassword = user.getPassword();
        //获取一个随机颜值
        String salt = UUID.randomUUID().toString().toUpperCase(Locale.ROOT);
        //补全颜值
        user.setSalt(salt);
        //将密码和颜值作为一个整体加密处理
        String md5Password = getMD5Password(oldePassword, salt);
        //将加密的密码重新补全到user对象中
        user.setPassword(md5Password);
        //补全数据:is_delete设置为0
        user.setIsDelete(0);
        //创建者和创建时间，修改者和修改时间是同一个人
        user.setCreatedUser(user.getUsername());
        user.setCreatedTime(new Date());
        user.setModifiedUser(user.getUsername());
        user.setModifiedTime(new Date());
        //执行注册业务功能的实现(rows==1),插入成功
        Integer rows = userMapper.insert(user);
        if (rows != 1) {
            throw new InsertException("用户在注册过程中产生了未知的异常");
        }
    }

    //定义一个md5的算法加密
    private String getMD5Password(String password, String salt) {
        //md5加密算法方法的调用
        for (int i = 0; i < 3; i++) {
            password = DigestUtils.md5DigestAsHex((salt + password + salt).getBytes(StandardCharsets.UTF_8)).toUpperCase(Locale.ROOT);
        }
        return password;
    }
}
```

3、在单元测试包下创建一个UserServiceTest类，在这个类中添加测试的功能

```java
package com.cy.store.Service;
@SpringBootTest
@RunWith(SpringRunner.class)
public class UserServiceTests {
    @Autowired
    private IUserService iUserService;
    
   @Test
    public void reg() {
        try {
            User user = new User();
            user.setUsername("张三");
            user.setPassword("123");
            iUserService.reg(user);
            System.out.println("OK");
        } catch (ServiceException e) {
            //获取类的对象，在获取类的名称
            System.out.println(e.getClass().getSimpleName());
            //在获取异常的具体描述信息
            System.out.println(e.getMessage());
        }
    }
}
```

#### #5 注册-控制层

###### 5.1 创建响应

1、状态码，状态描述信息，数据。这部分功能封装在一个类中，将这个类作为方法返回值，返回给前端浏览器。

```java
package com.cy.store.util;
/**
 * Json格式的数据进行响应
 */
@Data
public class JsonResult<E> implements Serializable {
    private Integer state; //状态码
    private String message; //描述信息
    private E data; //数据

    public JsonResult() {}

    public JsonResult(Integer state) {
        this.state = state;
    }

    public JsonResult(Throwable e) {
        this.message = e.getMessage();
    }

    public JsonResult(Integer state, E data) {
        this.data = data;
        this.state = state;
    }
}
```

###### 5.2 设计请求

1、依据当前对的业务功能模块进行请求的设计

```xml
请求的路径：/user/reg
请求的参数: user user
请求的类型: POST
响应结果： JSonResult<Void>
```

###### 5.3 处理请求

1、创建一个控制对应的类UserController类，依赖于业务层的接口。

```java
package com.cy.store.controller;
@RestController //@Controller+@RequestBody
//@Controller
@RequestMapping("/users")
@SuppressWarnings({"all"})
public class UserController extends BaseController {

    @Autowired
    private IUserService iUserService;

    /*
    //@RequestBody  表示此方法的响应结果以Json格式进行数据的响应给到前端
    @RequestMapping("reg")
    public JsonResult<Void> reg(User user) {
        //创建响应结果的对象
        JsonResult<Void> result = new JsonResult<>();
        try {
            iUserService.reg(user);
            result.setState(200);
            result.setMessage("注册成功");
        } catch (UsernameDuplicatedException e) {
            e.printStackTrace();
            result.setState(4000);
            result.setMessage("用户名被占用");
        } catch (InsertException e) {
            result.setState(5000);
            result.setMessage("注册时产生未知的异常");
        }
        return result;
    }
     */

    @RequestMapping("reg")
    public JsonResult<Void> reg(User user) {
        iUserService.reg(user);
        return new JsonResult<>(OK);
    }
}
```

###### 5.4 控制层优化设计

在控制抽离出来一个父类，在这个父类中统一的去处理关于异常的相关操作。编写一个BaseController类，统一处理异常。

```java
package com.cy.store.controller;
//控制层的基类，做异常处理
public class BaseController implements Serializable {
    public static final int OK = 200;//操作成功的状态码

    //请求处理方法，这个方法的返回值就是需要传递给前端的数据
    //自动将异常对象传递给此方法的参数列表上
    //项目中产生了异常，被统一拦截到此方法中，这个方法此时就是充当的是请求处理方法，方法的返回值直接给到前端
    @ExceptionHandler(ServerException.class) //用于统一处理抛出的异常
    public JsonResult<Void> handleException(Throwable e) {
        JsonResult<Void> result = new JsonResult<>(e);
        if (e instanceof UsernameDuplicatedException) {
            result.setState(4000);
            result.setMessage("用户名被占用");
        } else if (e instanceof InsertException) {
            result.setState(5000);
            result.setMessage("用户在注册时产生未知的异常");
        }
        return result;
    }
}

localhost:8081/users/reg?username=tom1&password=123
```

### (二) 用户登录

当用户输入用户名和密码将数据提交给后台数据库进行查询，如果存在对应的用户名和密码则表示登录成功，登录成功后跳转到系统的主页面就是index.html页面，跳转前端使用jquery来完成。

#### #1 登录-持久层

###### 1.1 规划需要执行的SQL语句

1、依据用户提交的用户名和密码做select查询，密码的比较在业务层执行

```mysql
select *from t_user where username=? and password=?
```

说明：如果分析过程中发现某一个功能的模块已经被开发完成，所以就可以省略当前的开发步骤，这个分析过程不能省略

###### 1.2 接口设计和方法

不要重复开发，单元测试也是无需单独执行

#### #2 登录-业务层

###### 2.1 规划异常

1、用户对应的密码错误，密码匹配失败异常：PasswordNotMatchException异常，运行时期异常，业务异常

```java
package com.cy.store.service.ex;
//密码不匹配异常
public class PasswordNotMatchException extends ServiceException{
    public PasswordNotMatchException() {
        super();
    }

    public PasswordNotMatchException(String message) {
        super(message);
    }

    public PasswordNotMatchException(String message, Throwable cause) {
        super(message, cause);
    }

    public PasswordNotMatchException(Throwable cause) {
        super(cause);
    }

    protected PasswordNotMatchException(String message, Throwable cause, boolean enableSuppression, boolean writableStackTrace) {
        super(message, cause, enableSuppression, writableStackTrace);
    }
}

```



2、用户名没有找到，抛出异常：UsernameNotFoundException。运行时异常，业务异常

```java
package com.cy.store.service.ex;
//用户名不匹配异常
public class UsernameNotFoundException extends ServiceException{
    public UsernameNotFoundException() {
        super();
    }

    public UsernameNotFoundException(String message) {
        super(message);
    }

    public UsernameNotFoundException(String message, Throwable cause) {
        super(message, cause);
    }

    public UsernameNotFoundException(Throwable cause) {
        super(cause);
    }

    protected UsernameNotFoundException(String message, Throwable cause, boolean enableSuppression, boolean writableStackTrace) {
        super(message, cause, enableSuppression, writableStackTrace);
    }
}

```

3、异常的编写：

-  业务层需要继承ServiceEcxeption异常类
-  在具体的异常类中定义构造方法(可以使用快捷键来生成，有五个构造方法)。

###### 2.2 设计业务层接口和抽象方法

1、直接在IUserSerivce接口中编写抽象方法，login(String username,String password); 将当前登录成功的用户数据以当前用户对象的形式进行返回。状态管理：可以将数据保存在cookie和session中，可以避免重复度很高的数据多次频繁操作数据进行获取(用户名、用户id-存放在session中，用户头像-cookie中)。

```java
package com.cy.store.service;
/**
 * 用户模块业务层接口
 */
public interface IUserService {
    /**
     * 用户登录功能
     * @param username 用户名
     * @param password 用户密码
     * @return 当前匹配的用户数据，如果没有则返回null值
     */
    User login(String username, String password);
}
```

###### 2.3 抽象方法的实现问题

1、需要在实现类中实现父类接口的抽象方法

```java
package com.cy.store.service.impl;
/**
 * 用户模块业务层的实现类
 */
@Service //将当前的对象交给Spring来管理，自动创建对象以及对象的维护
@SuppressWarnings({"all"})
public class UserServiceImpl implements IUserService {

    @Autowired
    private UserMapper userMapper;
  
    @Override
    public User login(String username, String password) {
        //根据用户的名称来查询用户的数据是否存在，如果不存在则抛出异常
        User result = userMapper.findByUsername(username);
        if (result == null) {
            throw new UsernameNotFoundException("用户数据不存在");
        }
        //检测用户的密码是否匹配
        //1、先获取到数据库中加密之后的密码
        String oldPassword = result.getPassword();
        //2、和用户传递过来的密码进行比较
        //2.1 先获取颜值：上一次在注册时所自动生成的颜值
        String salt = result.getSalt();
        //2.2 将用户的密码照相同的md5算法的规则进行加密
        String newMd5Password = getMD5Password(password, salt);
        //3、将密码进行比较
        if (!newMd5Password.equals(oldPassword)) {
            throw new PasswordNotMatchException("用户密码错误");
        }
        //判断is_delete字段的值是否为1表示字段标记为删除
        Integer isDelete = result.getIsDelete();
        if (isDelete == 1) {
            throw new UsernameNotFoundException("用户数据不存在");
        }
         //调用mapper层的findByUsername来查询用户的数据
        User user = userMapper.findByUsername(username);
        //将用户的数据返回,返回的数据是为了辅助其他页面做数据展示使用(uid,username,avatar)
        user.setUid(result.getUid());
        user.setUsername(result.getUsername());
        user.setAvatar(result.getAvatar());
        return user;
    }
}
```

2、在测试类中测试业务层登录的方法是否可以执行通过

#### #3 登录-控制层

###### 3.1 处理异常(业务层规划了异常)

1、业务层抛出的异常是什么，需要在统一异常处理类中进行统一的捕获和处理，如果也曾抛出的异常类型已经在统一异常处理类中曾经处理过，则不需要重复添加。

###### 3.2 设计请求

```
请求的路径：/user/login
请求的参数: String username,String password，HttpSession session
请求的类型: POST
响应结果： JSonResult<User>
```

###### 3.3 处理请求

1、在UserController类中编写处理请求的方法

```java
package com.cy.store.controller;
@RestController //@Controller+@RequestBody
//@Controller
@RequestMapping("/users")
@SuppressWarnings({"all"})
public class UserController extends BaseController {

    @Autowired
    private IUserService iUserService;  
    @RequestMapping("/login")
    public JsonResult<User> login(String username, String        password,HttpSession session) {
        User data = iUserService.login(username, password);
         //向session对象中完成数据的绑定(session全局的）
        session.setAttribute("uid", data.getUid());
        session.setAttribute("username", data.getUsername());
        //获取session中绑定的数据
        System.out.println(getuidFromSession(session));
        System.out.println(getUsernameFromSession(session));
        return new JsonResult<User>(OK,data);
    }
}

http://localhost:8081/users/login?username=tom&password=123
```

### (三) 用户会话session

session对象主要是存储在服务器端，可以用于保存服务器临时数据的对象。所保存的数据可以在整个项目中都可以通过访问来获取，把session的数据看做一个共享的数据。首次登陆的时候获取的用户的数据，转移到session对象即可。session.getAttrbute("key")可以将获取session中的数据这种行为进行封装，封装在BaseController类中

1、封装session对象中数据的获取(封装到父类中)，数据的设置(当用户登陆成功后进行数据的设置，设置到全局session对象)。

2、在父类中封装两个数据：获取uid和获取username对应的两个方法。用户头像不考虑，将来封装到cookie中来使用。

```java
package com.cy.store.controller;
//控制层的基类，做异常处理
public class BaseController implements Serializable {  
/**
     * 获取session对象中的uid
     * @param session session对象
     * @return 当前登陆的用户uid的值
     */
    protected final Integer getuidFromSession(HttpSession session) {
        return Integer.valueOf(session.getAttribute("uid").toString());
    }

    /**
     * 获取当前登陆用户的username
     * @param session session对象
     * @return 当前登陆用户的用户名
     */
    protected final String getUsernameFromSession(HttpSession session) {
        return session.getAttribute("username").toString();
    }
}
```

3、在登陆方法中将数据封装到session对象中。服务器本身自动创建有session对象，已经是一个全局的session对象。springboot直接使用session对象，直接将HttpSession类型的对象作为请求处理方法的参数，会自动将全局的session对象注入到请求处理方法的session形参上。

### (四) 拦截器

拦截器：首先将所有的请求统一拦截到拦截器中，可以在拦截器中定义过滤规则，如果不满足系统的设置的过滤规则，统一的处理去重新去打开login.html页面(重定向和转发),推荐重定向。

在springboot项目中拦截器的定义和使用。springboot是依靠springMvc来完成的。springMVC提供了一个Handlernterceptort接口，用于表示定义一个拦截器。受限制自定义一个类，在这个类实现这个接口。

1、首先自定义一个类，在这个类实现这个Handlernterceptort接口(拦截基本上在请求之前preHandle)。

```java
package com.cy.store.interceptor;
/**定义一个拦截器*/
public class LoginInterceptor implements HandlerInterceptor {
       /**
     * Controller方法处理之前
     * 检测全局session对象中是否有uid数据，如果有则放行，如果没有则重定向到登陆页面
     *
     * @param request  请求对象
     * @param response 响应对象
     * @param handler  处理器(url+Controller:映射)
     * @return 如果返回值值true表示放行当前的请求，如果返回值为false则表示拦截当前的请求。
     * @throws Exception
     */
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        // HttpServletRequest 对象来获取session对象
        Object obj = request.getSession().getAttribute("uid");
        if (obj == null) {  //说明用户没有登陆过系统，则重定向到login.html页面
            response.sendRedirect("/web/login.html");
            return false;  //结束后续的调用
        }
        return true;  //请求放行
    }
    
    //Controller方法处理之后
    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {
        HandlerInterceptor.super.postHandle(request, response, handler, modelAndView);
    }

    //Controller方法处理完之后，DispatcherServlet进行视图的渲染之前，也就是说在这个方法中你可以对ModelAndView进行操作
    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {
        HandlerInterceptor.super.afterCompletion(request, response, handler, ex);
    }
}
```

2、注册过滤器：添加白名单(那些资源可以在不登陆的情况下可以访问：

login.html\register.html\reg\index.html\product.html)、添加黑名单(在用户登录的页面下才可以访问的资源)

3、注册过滤的技术：借助WebMvcConfigure接口，可以将用户定义的拦截器进行注册，才可以保证拦截器才能生效和使用，定义一个类，然后让这个实现WebMvcConfigure接口。配置信息，建议存放在项目的config包结构下。

```java
package com.cy.store.config;
/**
 * 处理器拦截器的注册
 */
@Configuration //加载当前的拦截器并进行注册
public class LoginInterceptorConfigurer implements WebMvcConfigurer {
    //配置拦截器
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        //创建自定义的拦截器对象
        HandlerInterceptor interceptor = new LoginInterceptor();
        //配置白名单：存放在一个List集合中
        List<String> patterns = new ArrayList<>();
        patterns.add("/bootstrap3/**");
        patterns.add("/css/**");
        patterns.add("/images/**");
        patterns.add("/js/**");
        patterns.add("/web/register.html");
        patterns.add("/web/login.html");
        patterns.add("/web/index.html");
        patterns.add("/web/product.html");
        patterns.add("/web/reg");
        patterns.add("/web/login");
        //完成拦截器的注册/表示要拦截的URL是什么/除了什么方法之外
       registry.addInterceptor(interceptor).addPathPatterns("/**").excludePathPatterns(patterns);
    }
}
```

4、提示重定向次数过多，login.html页面无法打开。将浏览器cookie请求，再将浏览器设置为初始设置。

### (五) 修改密码

需要用户提交原始密码和新密码，在根据当前登陆的用户进行修改信息的修改操作

#### #1 修改-持久层

###### 1.1、规划需要执行的SQL语句

根据用户的uid修改用于的password值。

```mysql
updata t_user set password=?, modified_user=?,modified_time=? where uid=?;
```

跟据uid查询用户的数据,在修改密码之前，首先要保证当前用户的数据存在.检测是否被标记为删除，检测输入的原始密码是否正确

```mysql
select *from t_user where uid=?;
```

###### 1.2、设计接口和抽象方法

UserMapper接口,将以上的两个方法的抽象定义出来，将来映射到SQL语句上

```java
   /**
     * 根据用户的uid来修改用户的密码
     * @param uid 用户的id
     * @param password 用户的密码
     * @param modifiedUser 表示修改者
     * @param modifiedTime 表示修改时间
     * @return 返回值是受行数的影响
     */
    Integer updataPasswordByUid(Integer uid,String password,String modifiedUser,String modifiedTime);

    /**
     * 根据用户的id查询用户的数据
     * @param uid 用户的id
     * @return 如果找到则返回对象，反之返回null
     */
    User findByUid(Integer uid);
```

###### 3、编写SQL

```mysql
  <update id="updataPasswordByUid">
        UPDATE
            t_user
        set password= #{password},
            modified_user= #{modeifiedUser},
            modified_time=#{modeifiedTime}
        where uid = #{uid};
    </update>

    <!-- 1、resultmap：resultMap如果查询出来的列名和pojo的属性名不一致，通过定义一个resultMap对列名和pojo属性名之间作一个映射关系。
        2、resultType：resultType使用resultType进行输出映射，只有查询出来的列名和pojo中的属性名一致，该列才可以映射成功。-->
    <select id="findByUid" resultMap="UserEntityMap">
        select *
        from t_user
        where uid = #{uid}
    </select>
```

单元测试功能的测试。

#### #2 修改-业务层

###### 2.1 规划异常

1、用户的原密码错误，is_delete==1表示已经被删除、当前的用户找不到，用户没有发现的异常（已经存在）

2、update在更新的时候，有可能产生未知的异常，UpdateException

```java
package com.cy.store.service.ex;

public class UpdateException extends ServiceException{
    public UpdateException() {
        super();
    }

    public UpdateException(String message) {
        super(message);
    }

    public UpdateException(String message, Throwable cause) {
        super(message, cause);
    }

    public UpdateException(Throwable cause) {
        super(cause);
    }

    protected UpdateException(String message, Throwable cause, boolean enableSuppression, boolean writableStackTrace) {
        super(message, cause, enableSuppression, writableStackTrace);
    }
}

```

###### 2.2 设计业层务接口和抽象方法

1、执行的用户修改密码的核心方法

```java
 /**
     * 修改用户的密码 
     * @param uid 查询用户的ID
     * @param username 查询用户的名称
     * @param oldPassword 获取原有的密码
     * @param newPassword 更新密码
     */
    void changePassword(Integer uid,String username,String oldPassword,String newPassword);
```

###### 2.3 抽象方法的实现问题

1、实现接口的方法

```java
package com.cy.store.service.impl;
/**
 * 用户模块业务层的实现类
 */
@Service //将当前的对象交给Spring来管理，自动创建对象以及对象的维护
@SuppressWarnings({"all"})
public class UserServiceImpl implements IUserService {

    @Autowired
    private UserMapper userMapper;
/**
     * 修改密码
     *
     * @param uid         查询用户的ID
     * @param username    查询用户的名称
     * @param oldPassword 获取原有的密码
     * @param newPassword 更新密码
     */
    @Override
    public void changePassword(Integer uid, String username, String oldPassword, String newPassword) {
        User result = userMapper.findByUid(uid);
        if (result == null || result.getIsDelete() == 1) {
            throw new UsernameNotFoundException("用户数据不存在");
        }
        //原始密码和数据库的密码进行比较
        String oldMd5Password = getMD5Password(oldPassword, result.getSalt());
        if (!oldMd5Password.equals(result.getPassword())) {
            throw new PasswordNotMatchException("密码错误");
        }
        //将新密码设置到数据库中，将行的密码在进行加密去更新
        String newMd5Password = getMD5Password(newPassword, result.getSalt());
        userMapper.updatePasswordByUid(result.getUid(), newMd5Password, result.getModifiedUser(), new Date());
    }
}
```

单元测试;

#### #3 修改-控制层

###### 3.1 处理异常

UpdateExcetion需要配置到统一的异常处理中。

###### 3.2 设计请求

```properties
请求的路径：/users/change_password
请求的参数: 
         String oldPassword,String newPassword ,HttpSession session需要和表单中的name属性值保持一致
请求的类型: POST
响应结果： JsonResult<Void>
```

###### 3.3 请求处理

```java
   @RequestMapping("/change_password")
    public JsonResult<Void> changePassword(String oldPassword, String newPassword, HttpSession session) {
        Integer uid = getuidFromSession(session);
        String useranme = getUsernameFromSession(session);
        iUserService.changePassword(uid, useranme, oldPassword, newPassword);
        return new JsonResult<Void>(OK);
    }

http://localhost:8080/users/change_password?oldPassword=?&newPassword=?
```

### (六) 用户的信息修改

#### #1 修改信息-持久层

###### 1.1 规划需要执行的SQL语句

1、根据用户的SQL语句

```mysql
update t_user set phone=?,email=?,gender=?,modified_user=?,modified_time=? where uid=?;
```

2、根据用户名查询用户的数据

```mysql
select *from t_user where uid=?;
```

- 查询用户的数据不需要在重新开发。
- 为什么是两个SQL语句：因为切换到页面要在数据库中返回信息，修改后也要返回信息。

###### 1.2 设计接口和抽象方法

1、更新用户的信息

```java
    /** 根据uid更新用户资料
     * @param user 封装了用户id和新个人资料的对象
     * @return 受影响的行数
     */
    Integer updateInfoByUid(User user);
```

###### 1.3 编写SQL

```xml
  <!-- 根据uid更新用户个人资料：Integer updateInfoByUid(User user) -->
 <!--if表示条件判断标签，test接收的是一个返回值为boolean类型的条件，如果test条件的结果为true则执行if
    标签内部的语句-->
    <update id="updateInfoByUid">
        UPDATE
            t_user
        SET
            <if test="phone != null">phone = #{phone},</if>
            <if test="email != null">email = #{email},</if>
            <if test="gender != null">gender = #{gender},</if>
            modified_user = #{modifiedUser},
            modified_time = #{modifiedTime}
        WHERE
            uid = #{uid}
```

单元测试

#### #2 修改信息-业务层

###### 1.1 异常规划

1、设计两个功能：

- 当前打开页面是获取用户的信息并且填充到对应的文本中
- 检测用户是否忘记了点击修改按钮，如果检测到则执行修改用户信息的操作

2、打开页面的时候可能找不到用户的数据，点击删除按钮之前需要再次去检测用户的数据是否存在

###### 2.2 接口和抽象方法

主要的两个功能模块，对应的是两个抽象的方法的设计

```java
    /**
     * 获取当前登录的用户的信息
     * @param uid 当前登录的用户的id
     * @return 当前登录的用户的信息
     */
    User getByUid(Integer uid);    

    /**
     * 修改用户资料
     * @param uid 当前登录的用户的id
     * @param username 当前登录的用户名
     * @param user 用户的新的数据
     */
    void changeInfo(Integer uid, String username, User user);
```

###### 2.3 实现抽象方法

在UserServiceImpl类中添加两个抽象方法的具体实现。

```java
    @Override
    public User getByUid(Integer uid) {
        // 调用userMapper的findByUid()方法，根据参数uid查询用户数据
        User result = userMapper.findByUid(uid);
        // 判断查询结果是否为null
        if (result == null) {
            // 是：抛出UserNotFoundException异常
            throw new UserNotFoundException("用户数据不存在");
        }

        // 判断查询结果中的isDelete是否为1
        if (result.getIsDelete().equals(1)) {
            // 是：抛出UserNotFoundException异常
            throw new UserNotFoundException("用户数据不存在");
        }

        // 创建新的User对象
        User user = new User();
        // 将以上查询结果中的username/phone/email/gender封装到新User对象中
        user.setUsername(result.getUsername());
        user.setPhone(result.getPhone());
        user.setEmail(result.getEmail());
        user.setGender(result.getGender());

        // 返回新的User对象
        return user;
    }


    /** user对象中的数据phone\email\gender，手动再将                      uid\username封装到user对象中
     */
     @Override
    public void changeInfo(Integer uid, String username, User user) {
        // 调用userMapper的findByUid()方法，根据参数uid查询用户数据
        User result = userMapper.findByUid(uid);
        // 判断查询结果是否为null
        if (result == null) {
            // 是：抛出UserNotFoundException异常
            throw new UserNotFoundException("用户数据不存在");
        }

        // 判断查询结果中的isDelete是否为1
        if (result.getIsDelete().equals(1)) {
            // 是：抛出UserNotFoundException异常
            throw new UserNotFoundException("用户数据不存在");
        }

        // 向参数user中补全数据：uid
        user.setUid(uid);
        // 向参数user中补全数据：modifiedUser(username)
        user.setModifiedUser(username);
        // 向参数user中补全数据：modifiedTime(new Date())
        user.setModifiedTime(new Date());
        // 调用userMapper的updateInfoByUid(User user)方法执行修改，并获取返回值
        Integer rows = userMapper.updateInfoByUid(user);
        // 判断以上返回的受影响行数是否不为1
        if (rows != 1) {
            // 是：抛出UpdateException异常
            throw new UpdateException("更新用户数据时出现未知错误，请联系系统管理员");
        }
    }
```

#### #3 修改信息-控制层

###### 3.1 处理异常

暂时无新的异常。

###### 3.2 设计请求

1、设置一打开页面就发送当前用户数据查询

```java
请求的路径：/users/get_by_uid
请求的参数: HttpSession session
请求的类型: GET
响应结果： JsonResult<User>
```

2、点击修改按钮发送用户的数据修改操作请求的设计

```java
请求的路径：/users/change_info
请求的参数: HttpSession session,User user
请求的类型: POST
响应结果： JsonResult<Void>
```

###### 3.3 请求处理

```java
@GetMapping("get_by_uid")
    public JsonResult<User> getByUid(HttpSession session) {
        // 从HttpSession对象中获取uid
        Integer uid = getUidFromSession(session);
        // 调用业务对象执行获取数据
        User data = userService.getByUid(uid);
        // 响应成功和数据
        return new JsonResult<User>(OK, data);
    }

    @RequestMapping("change_info")
    public JsonResult<Void> changeInfo(User user, HttpSession session) {
        // 从HttpSession对象中获取uid和username
        Integer uid = getUidFromSession(session);
        String username = getUsernameFromSession(session);
        // 调用业务对象执行修改用户资料
        userService.changeInfo(uid, username, user);
        // 响应成功
        return new JsonResult<Void>(OK);
    }
```

### (七) 上传头像

#### #1 上传头像-持久层

###### 1.1 规划需要执行的SQL语句

1、将对应的文件保存到操作系统上，然后在把这个文件路径给记录在，因为在记录路径的是非常便捷和方便，将如果要打开这个文件可以依据这个路径找到这个文件。在数据库中需要保存这个文件的路径即可。将左右的静态资源(图片、文件、其他资源文件)放到某台电脑上，咋子把这台电脑作为一个单独的服务器使用。

对应的是一个更新用户avatar字段的sql语句

```mysql
update t_user set avatar=?,modified_user=?,modified_time=? where uid=?;
```

###### 1.2 设计接口和抽象方法

1、UserMapper接口中定义一个抽象方法用于修改用户的头像

```java
     /**
     * @param uid          用户的id
     * @param avatar       新头像的路径
     * @param modifiedUser 修改执行人
     * @param modifiedTime 修改时间
     * @return 受影响的行数
     * @Param("SQL映射文件中#{}占位符的变量名"):解决的问题，当SQl语句的占位符和映射的参数方法参数名不一致是， 
     * 需要将某个参数强行注入到某个占位符变量时，可以使用@Param这个注解来标注映射的关系
     * 根据uid更新用户的头像
     */
    Integer updateAvatarByUid(
            @Param("uid") Integer uid,
            @Param("avatar") String avatar,
            @Param("modifiedUser") String modifiedUser,
            @Param("modifiedTime") Date modifiedTime);
```

###### 1.3 编写SQL

```mysql
   <update id="updateAvatarByUid">
        UPDATE
            t_user
        SET avatar = #{avatar},
            modified_user = #{modifiedUser},
            modified_time = #{modifiedTime}
        WHERE uid = #{uid}
     </update>
```

单元测试：

#### #2 上传头像-业务层

###### 2.1 异常规划

1、用户数据不存在，找不到对应的用户数据

2、更新的时候，产生未知的异常

无需重复开发

###### 2.2 接口和抽象方法

在IUserService中设计接口

```java
 /**
     * 修改用户头像
     * @param uid 当前登录的用户的id
     * @param username 当前登录的用户名
     * @param avatar 用户的新头像的路径
     */
    void changeAvatar(Integer uid, String username, String avatar);
```

###### 2.3 实现抽象方法

```java
@Override
    public void changeAvatar(Integer uid, String username, String avatar) {
        // 调用userMapper的findByUid()方法，根据参数uid查询用户数据
        User result = userMapper.findByUid(uid);
        // 检查查询结果是否为null
        if (result == null) {
            // 是：抛出UserNotFoundException
            throw new UserNotFoundException("用户数据不存在");
        }

        // 检查查询结果中的isDelete是否为1
        if (result.getIsDelete().equals(1)) {
            // 是：抛出UserNotFoundException
            throw new UserNotFoundException("用户数据不存在");
        }

        // 创建当前时间对象
        Date now = new Date();
        // 调用userMapper的updateAvatarByUid()方法执行更新，并获取返回值
        Integer rows = userMapper.updateAvatarByUid(uid, avatar, username, now);
        // 判断以上返回的受影响行数是否不为1
        if (rows != 1) {
            // 是：抛出UpdateException
            throw new UpdateException("更新用户数据时出现未知错误，请联系系统管理员");
        }
    }
```

#### #3 上传头像-控制层

###### 3.1 异常规划

```java
fileUploadException 文件上传的异常(父类) 继承RuntimmeException
fileEmptyException 文件为空的异常
fileSizeException 文件大小超出限制
fileTypeException 文件类型异常
fileUploadIOException 文件读写的异常
fileSataeExcepton  上传的文件状态异常
```

###### 3.2 异常处理

在基类BseController类中进行编写和统一处理

###### 3.3 设计请求

```
请求的路径：/users/change_avatar
请求的参数: HttpSession session，MultipartFile file
请求的类型: GET
响应结果： JsonResult<String>
```

###### 3.3 请求处理

在UserController中实现

```java
 /** 头像文件大小的上限值(10MB) */
    public static final int AVATAR_MAX_SIZE = 10 * 1024 * 1024;
    /** 允许上传的头像的文件类型 */
    public static final List<String> AVATAR_TYPES = new ArrayList<String>();

    /** 初始化允许上传的头像的文件类型 */
    static {
        AVATAR_TYPES.add("image/jpeg");
        AVATAR_TYPES.add("image/png");
        AVATAR_TYPES.add("image/bmp");
        AVATAR_TYPES.add("image/gif");
    }

 /**
     * MultipartFile 接口是springMVC提供的一个接口，这个接口为我们包装了获取文件类型的数据(任何类型的file都可以接收)，springboot
     * 它邮政整合了springMVC，只需要在处理请求的方法参数列表上声明一个参数类型为MultipartFile的参数，然后springboot自动
     * 将传递给服务的文件数据赋值给这个参数
     *
     * @RequestParam 表示在请求中的参数，将请求中的参数注入请求处理方法的某个参数，如果名称不一致则可以使用@RequestParam
     * 注解进行标记和映射
     */
    @PostMapping("change_avatar")
    public JsonResult<String> changeAvatar(@RequestParam("file") MultipartFile file, HttpSession session) {
        // 判断上传的文件是否为空
        if (file.isEmpty()) {
            // 是：抛出异常
            throw new FileEmptyException("上传的头像文件不允许为空");
        }

        // 判断上传的文件大小是否超出限制值
        if (file.getSize() > AVATAR_MAX_SIZE) { // getSize()：返回文件的大小，以字节为单位
            // 是：抛出异常
            throw new FileSizeException("不允许上传超过" + (AVATAR_MAX_SIZE / 1024) + "KB的头像文件");
        }

        // 判断上传的文件类型是否超出限制
        String contentType = file.getContentType();
        // boolean contains(Object o)：当前列表若包含某元素，返回结果为true；若不包含该元素，返回结果为false
        if (!AVATAR_TYPES.contains(contentType)) {
            // 是：抛出异常
            throw new FileTypeException("不支持使用该类型的文件作为头像，允许的文件类型：" + AVATAR_TYPES);
        }

        // 获取当前项目的绝对磁盘路径
        String parent = session.getServletContext().getRealPath("upload");
        System.out.println(parent);
        // 保存头像文件的文件夹
        File dir = new File(parent);
        if (!dir.exists()) {
            dir.mkdirs();
        }

        // 保存的头像文件的文件名
        String suffix = "";
        String originalFilename = file.getOriginalFilename();
        int beginIndex = originalFilename.lastIndexOf(".");
        if (beginIndex > 0) {
            suffix = originalFilename.substring(beginIndex);
        }
        String filename = UUID.randomUUID().toString() + suffix;

        // 创建文件对象，表示保存的头像文件
        File dest = new File(dir, filename);
        // 执行保存头像文件
        try {
            file.transferTo(dest);
        } catch (IllegalStateException e) {
            // 抛出异常
            throw new FileStateException("文件状态异常，可能文件已被移动或删除");
        } catch (IOException e) {
            // 抛出异常
            throw new FileUploadIOException("上传文件时读写错误，请稍后重新尝试");
        }

        // 头像路径
        String avatar = "/upload/" + filename;
        // 从Session中获取uid和username
        Integer uid = getUidFromSession(session);
        String username = getUsernameFromSession(session);
        // 将头像写入到数据库中
        userService.changeAvatar(uid, username, avatar);

        // 返回成功头像路径
        return new JsonResult<String>(OK, avatar);
    }
```

### (八) 新增收货地址

新建收货地址的数据库创建

```mysql
CREATE TABLE t_address (
	aid INT AUTO_INCREMENT COMMENT '收货地址id',
	uid INT COMMENT '归属的用户id',
	name VARCHAR(20) COMMENT '收货人姓名',
	province_name VARCHAR(15) COMMENT '省-名称',
	province_code CHAR(6) COMMENT '省-行政代号',
	city_name VARCHAR(15) COMMENT '市-名称',
	city_code CHAR(6) COMMENT '市-行政代号',
	area_name VARCHAR(15) COMMENT '区-名称',
	area_code CHAR(6) COMMENT '区-行政代号',
	zip CHAR(6) COMMENT '邮政编码',
	address VARCHAR(50) COMMENT '详细地址',
	phone VARCHAR(20) COMMENT '手机',
	tel VARCHAR(20) COMMENT '固话',
	tag VARCHAR(6) COMMENT '标签',
	is_default INT COMMENT '是否默认：0-不默认，1-默认',
	created_user VARCHAR(20) COMMENT '创建人',
	created_time DATETIME COMMENT '创建时间',
	modified_user VARCHAR(20) COMMENT '修改人',
	modified_time DATETIME COMMENT '修改时间',
	PRIMARY KEY (aid)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
```

#### #1 新增收货地址-持久层

###### 1.1 各功能的开发顺序

当前收货地址功能模块：列表的展示，修改，删除，设置默认，新增收货地址。

开发顺序: 设置默认收货地址-删除收货地址-修改收货地址

###### 1.2 规划需要执行的SQL语句

1、创建一个类Address类，在类中定义表中的相关字段，采用驼峰命名的方式。

```java
package com.cy.store.entity;

import java.io.Serializable;

/** 收货地址数据的实体类 */
@Data
public class Address extends BaseEntity implements Serializable {
    private Integer aid;
    private Integer uid;
    private String name;
    private String provinceName;
    private String provinceCode;
    private String cityName;
    private String cityCode;
    private String areaName;
    private String areaCode;
    private String zip;
    private String address;
    private String phone;
    private String tel;
    private String tag;
    private Integer isDefault;
    }
```

2、新建收货地址接口AddressMapper

- 对应是插入语句

```mysql
insert into t_address (除了aid字段列表) values (字段列表)
```

- 一个用户的收货地址规定最多只能有20条对应的数据。收货地址逻辑控制方面的异常。

```mysql
select count(*) t_address where aid=?;
```

###### 1.3 接口于抽象方法

1、对应是插入地址语句

```java
   /**
     * 插入收货地址数据
     * @param address 收货地址数据
     * @return 受影响的行数
     */
Integer insert(Address address);
```

2、对应的是数据收货地址数据的条数

```java
/**
     * 统计某用户的收货地址数据的数量
     * @param uid 用户的id
     * @return 该用户的收货地址数据的数量
     */
Integer countByUid(Integer uid);
```

###### 1.4 配置SQL映射

1、创建地址映射AddressMapper.xml

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.cy.store.mapper.AddressMapper">

    <resultMap id="AddressEntityMap" type="com.cy.store.entity.Address">
        <id column="aid" property="aid"/>
        <result column="province_code" property="provinceCode"/>
        <result column="province_name" property="provinceName"/>
        <result column="city_code" property="cityCode"/>
        <result column="city_name" property="cityName"/>
        <result column="area_code" property="areaCode"/>
        <result column="area_name" property="areaName"/>
        <result column="is_default" property="isDefault"/>
        <result column="created_user" property="createdUser"/>
        <result column="created_time" property="createdTime"/>
        <result column="modified_user" property="modifiedUser"/>
        <result column="modified_time" property="modifiedTime"/>
    </resultMap>
</mapper>
```

2、插入收货地址

```mysql
   <!-- 插入收货地址数据：Integer insert(Address address) -->
<insert id="insert" useGeneratedKeys="true" keyProperty="aid">
        INSERT INTO t_address (
            uid, name, province_name, province_code, city_name, city_code, area_name, area_code, zip,
            address, phone, tel, tag, is_default, created_user, created_time, modified_user, modified_time
        ) VALUES (
            #{uid}, #{name}, #{provinceName}, #{provinceCode}, #{cityName}, #{cityCode}, #{areaName},
            #{areaCode}, #{zip}, #{address}, #{phone}, #{tel}, #{tag}, #{isDefault}, #{createdUser},
            #{createdTime}, #{modifiedUser}, #{modifiedTime}
        )
 </insert>
```

3、统计用户数量

```mysql
 <!-- 统计某用户的收货地址数据的数量：Integer countByUid(Integer uid) -->
<select id="countByUid" resultType="java.lang.Integer">
        SELECT
            COUNT(*)
        FROM
            t_address
        WHERE
            uid=#{uid}
</select>
```

单元测试

#### #2 新增收货地址-业务层

###### 2.1 异常规划

- 如果用户是第一次插入用户的地址，规则：当用户插入的地址是第一条时，需要将用户的当前地址作为默认的收货地址，如果查询到统计总数为0则将当前的地址的is_default值设置为1。查询统计的结果为0不代表异常。

- 查询到的结果大于20了，这时需要抛出业务控制的异常AdddressCountLimitException异常。自行创建这个异常

###### 2.2 接口和抽象方法

1、创建一个IAddressService接口，在定义业务的抽象方法。

```java
/**
     * 创建新的收货地址
     * @param uid 当前登录的用户的id
     * @param username 当前登录的用户名
     * @param address 用户提交的收货地址数据
     */
    void addNewAddress(Integer uid, String username, Address address);
```

2、创建一个AddressService实现类，去实现接口中抽象方法

```java
  @Value("${user.address.max-count}")
    private int maxCount;

    @Override
    public void addNewAddress(Integer uid, String username, Address address) {
        // 根据参数uid调用addressMapper的countByUid(Integer uid)方法，统计当前用户的收货地址数据的数量
        Integer count = addressMapper.countByUid(uid);
        // 判断数量是否达到上限值
        if (count > maxCount) {
            // 是：抛出AddressCountLimitException
            throw new AddressCountLimitException("收货地址数量已经达到上限(" + maxCount + ")！");
        }

        // 补全数据：省、市、区的名称
        String provinceName = districtService.getNameByCode(address.getProvinceCode());
        String cityName = districtService.getNameByCode(address.getCityCode());
        String areaName = districtService.getNameByCode(address.getAreaCode());
        address.setProvinceName(provinceName);
        address.setCityName(cityName);
        address.setAreaName(areaName);

        // 补全数据：将参数uid封装到参数address中
        address.setUid(uid);
        // 补全数据：根据以上统计的数量，得到正确的isDefault值(是否默认：0-不默认，1-默认)，并封装
        Integer isDefault = count == 0 ? 1 : 0;
        address.setIsDefault(isDefault);
        // 补全数据：4项日志
        Date now = new Date();
        address.setCreatedUser(username);
        address.setCreatedTime(now);
        address.setModifiedUser(username);
        address.setModifiedTime(now);

        // 调用addressMapper的insert(Address address)方法插入收货地址数据，并获取返回的受影响行数
        Integer rows = addressMapper.insert(address);
        // 判断受影响行数是否不为1
        if (rows != 1) {
            // 是：抛出InsertException
            throw new InsertException("插入收货地址数据时出现未知错误，请联系系统管理员！");
        }
    }
```

3、测试业务层的功能是否正常

###### 2.3 实现抽象方法

1、创建一个表现层AddressController类

```java
package com.cy.store.controller;
@RestController
@RequestMapping("addresses")
@SuppressWarnings({"all"})
public class AddressController extends BaseController {
    @Autowired
    private IAddressService addressService;
@RequestMapping("add_new_address")
    public JsonResult<Void> addNewAddress(Address address, HttpSession session) {
        // 从Session中获取uid和username
        Integer uid = getUidFromSession(session);
        String username = getUsernameFromSession(session);

        // 调用业务对象的方法执行业务
        addressService.addNewAddress(uid, username, address);
        // 响应成功
        return new JsonResult<Void>(OK);
    }
}
```

#### #3 新增收货地址-控制层

###### 3.1 处理异常

业务层抛出了收货地址总数超标的异常，在BaseController中处理。

```java
else if (e instanceof AddressCountLimitException) {
            result.setState(4003);
    result.setMessage("用户的收货地址超出上限异常")
}
```

###### 3.2 设计请求

```xml
请求的路径：/users/add_new_address
请求的参数: HttpSession session，Address address
请求的类型: POST
响应结果： JsonResult<Void>
```

###### 3.3 处理请求

```java
package com.cy.store.controller;
@RestController
@RequestMapping("addresses")
@SuppressWarnings({"all"})
public class AddressController extends BaseController {
    @Autowired
    private IAddressService addressService;

    @RequestMapping("add_new_address")
    public JsonResult<Void> addNewAddress(Address address, HttpSession session) {
        // 从Session中获取uid和username
        Integer uid = getUidFromSession(session);
        String username = getUsernameFromSession(session);

        // 调用业务对象的方法执行业务
        addressService.addNewAddress(uid, username, address);
        // 响应成功
        return new JsonResult<Void>(OK);
}
```

### (九)获取省市区编号列表

#### #1 获取省市区编号-持久层

###### 1.1 数据库

```mysql 
CREATE TABLE t_dict_district (
  id int(11) NOT NULL AUTO_INCREMENT,
  parent varchar(6) DEFAULT NULL,
  code varchar(6) DEFAULT NULL,
  name varchar(16) DEFAULT NULL,
  PRIMARY KEY (id)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

```

parent 表示的是父区编码号，省的编码号+86.

###### 1.2 实体类

创建一个District的实体类

```java
/** 省/市/区数据的实体类 */
@Data
public class District implements Serializable {
    private Integer id;
    private String parent;
    private String code;
    private String name;
}
```

###### 1.3 规划需要开发的SQL语句

查询语句，根据父类查询语句。

```mysql
select *from t_dict_district where parent=? order by code ASC;
```

抽象方法定义，创建一个新的接口DIstrict

```java
package com.cy.store.mapper;
/** 处理省/市/区数据的持久层接口 */
public interface DistrictMapper {
    /**
     * 获取全国所有省/某省所有市/某市所有区
     * @param parent 父级代号，当获取某市所有区时，使用市的代号；当获取省所有市时，使用省的代号；当获取全国所有省时，使用"86"作为父级代号
     * @return 全国所有省/某省所有市/某市所有区的列表
     */
    List<District> findByParent(String parent);

}
```

###### 1.4 实现SQL语句的编写

```mysql
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.cy.store.mapper.DistrictMapper">
    <!-- 获取全国所有省/某省所有市/某市所有区：List<District> findByParent(String parent) -->
    <select id="findByParent" resultType="com.cy.store.entity.District">
        SELECT
            *
        FROM
            t_dict_district
        WHERE
            parent=#{parent}
        ORDER BY
            code ASC
    </select>
</mapper>
```

单元测试。

#### #2 获取省市区编号-业务层

###### 2.1 异常规划

暂无。

###### 2.2 接口与抽象方法

1、创建一个SistrictService接口，并定义抽象方法。

```java
package com.cy.store.service;
/** 处理省/市/区数据的业务层接口 */
public interface IDistrictService {
    /**
     * 获取全国所有省/某省所有市/某市所有区
     * @param parent 父级代号，当获取某市所有区时，使用市的代号；当获取某省所有市时，使用省的代号；当获取全国所有省时，使用"86"作为父级代号
     * @return 全国所有省/某省所有市/某市所有区的列表
     */
    List<District> getByParent(String parent);
```

###### 2.3 实现抽象方法

1、创建一个DistrictServiceImpl实现类，实现抽象方法

```java
package com.cy.store.service.impl;
/** 处理省/市/区数据的业务层实现类 */
@Service
@SuppressWarnings({"all"})
public class DistrictServiceImpl implements IDistrictService {
    @Autowired
    private DistrictMapper districtMapper;

    @Override
    public List<District> getByParent(String parent) {
        List<District> list = districtMapper.findByParent(parent);
        for (District district : list) {
            district.setId(null);
            district.setParent(null);
        }
        return list;
    }
}
```

单元测试。

#### #3 获取省市区编号-控制层

###### 3.1 处理异常

暂无。

###### 3.2 设置请求

```java
请求路径：/district/
请求类型：GET
请求参数：String parent
响应结果：JsonResult<List<District>>
```

###### 3.3 处理请求

```java
package com.cy.store.controller;
@RestController
@RequestMapping("districts")
public class DistrictController extends BaseController {
    @Autowired
    private IDistrictService districtService;

    @GetMapping({"", "/"})
    //@RequestMapping(method={RequestMethod.GET})
    public JsonResult<List<District>> getByParent(String parent) {
        List<District> data = districtService.getByParent(parent);
        return new JsonResult<>(OK, data);
    }
}

```

### (十) 获取省市区名称

#### #1 获取省市区名称-持久层

###### 1.1 规划需要编写的SQL语句

通过code的编码来获取区域的名称

```java
String findNameByCode(String code);
```

###### 1.2 实现SQL语句

在DistrictMapper.xml下实现SQL的编写

```java
    <!-- 根据省/市/区的行政代号获取省/市/区的名称：String findNameByCode(String code) -->
    <select id="findNameByCode" resultType="java.lang.String">
        SELECT
            name
        FROM
            t_dict_district
        WHERE
            code=#{code}
    </select>
```

单元测试；

#### #2 获取省市区名称-业务层

###### 1.1 异常规划

暂无；

###### 1.2 规划接口和抽象方法

```java
  /**
     * 根据省/市/区的行政代号获取省/市/区的名称
     * @param code 省/市/区的行政代号
     * @return 匹配的省/市/区的名称，如果没有匹配的数据则返回null
     */
    String getNameByCode(String code);
```

###### 1.3 实现接口

```java
 @Override
    public String getNameByCode(String code) {
        return districtMapper.findNameByCode(code);
    }
```

在接口方法实现后，在AddressServiceImpl中引用getNameByCode方法,返回省市区的名称。

```java
package com.cy.store.service.impl;
@Service
@SuppressWarnings({"all"})
public class AddressServiceImpl implements IAddressService {
    @Autowired
    private AddressMapper addressMapper;

    @Autowired
    private IDistrictService districtService;

    @Value("${user.address.max-count}")
    private int maxCount;

    @Override
    public void addNewAddress(Integer uid, String username, Address address) {
        // 根据参数uid调用addressMapper的countByUid(Integer uid)方法，统计当前用户的收货地址数据的数量
        Integer count = addressMapper.countByUid(uid);
        // 判断数量是否达到上限值
        if (count > maxCount) {
            // 是：抛出AddressCountLimitException
            throw new AddressCountLimitException("收货地址数量已经达到上限(" + maxCount + ")！");
        }

        // 补全数据：省、市、区的名称
        String provinceName = districtService.getNameByCode(address.getProvinceCode());
        String cityName = districtService.getNameByCode(address.getCityCode());
        String areaName = districtService.getNameByCode(address.getAreaCode());
        address.setProvinceName(provinceName);
        address.setCityName(cityName);
        address.setAreaName(areaName);

        // 补全数据：将参数uid封装到参数address中
        address.setUid(uid);
        // 补全数据：根据以上统计的数量，得到正确的isDefault值(是否默认：0-不默认，1-默认)，并封装
        Integer isDefault = count == 0 ? 1 : 0;
        address.setIsDefault(isDefault);
        // 补全数据：4项日志
        Date now = new Date();
        address.setCreatedUser(username);
        address.setCreatedTime(now);
        address.setModifiedUser(username);
        address.setModifiedTime(now);

        // 调用addressMapper的insert(Address address)方法插入收货地址数据，并获取返回的受影响行数
        Integer rows = addressMapper.insert(address);
        // 判断受影响行数是否不为1
        if (rows != 1) {
            // 是：抛出InsertException
            throw new InsertException("插入收货地址数据时出现未知错误，请联系系统管理员！");
        }
    }
}
```

#### #3 获取省市区名称-控制层

无。

### (十一) 获取收货地址展示列表

#### #1 展示收货地址-持久层

###### 1.1 规划需要的SQL语句

通过查找用户uid展示出用户的收货地址

```mysql
select *from t_address where uid=?;
```

###### 1.2 设计接口和抽象方法

在接口AddressMapper中规划

```java
 /**
     * 查询某用户的收货地址列表数据
     * @param uid 收货地址归属的用户id
     * @return 该用户的收货地址列表数据
     */
List<Address> findByUid(Integer uid);
```

###### 1.3 编写SQL语句

在AddressMapper.xml中实现编写接口SQL语句：

用户的收货默认收货地址排在第一个，然后按照时间的升序排序手绘地址。

```xml
 <!-- 查询某用户的收货地址列表数据：List<Address> findByUid(Integer uid) -->
    <select id="findByUid" resultMap="AddressEntityMap">
        SELECT
            *
        FROM
            t_address
        WHERE
            uid=#{uid}
        ORDER BY
            is_default DESC, created_time DESC
    </select>
```

单元测试。

#### #2 展示收货地址-业务层

###### 2.1 规划异常

AddressNotFoundException收货地址的数据不存在。

###### 2.2 设计接口和抽象方法

```java
    /**
     * 查询某用户的收货地址列表数据
     * @param uid 收货地址归属的用户id
     * @return 该用户的收货地址列表数据
     */
    List<Address> getByUid(Integer uid);
```

###### 2.3 实现接口和抽象方法

```java
 @Override
    public List<Address> getByUid(Integer uid) {
 List<Address> list = addressMapper.findByUid(uid);
        /*
        for (Address address : list) {
            address.setUid(null);
            address.setProvinceCode(null);
            address.setCityCode(null);
            address.setAreaCode(null);
            address.setCreatedUser(null);
            address.setCreatedTime(null);
            address.setModifiedUser(null);
            address.setModifiedTime(null);
        }*/
        return list;
    }
```

单元测试。

#### #3 展示收货地址-控制层

###### 3.1 处理异常

```java
else if (e instanceof AddressNotFoundException) {
            result.setState(4004);
            }
```

###### 3.2 设计请求

```java
请求路径：@GetMapping({"", "/"})
请求参数：HttpSession session
请求类型：List<Address>
响应结果：JsonResult<List<Address>> (Ok,Data)
```

###### 3.3 处理请求

```java
   @GetMapping({"", "/"})
    public JsonResult<List<Address>> getByUid(HttpSession session) {
        Integer uid = getUidFromSession(session);
        List<Address> data = addressService.getByUid(uid);
        return new JsonResult<List<Address>>(OK, data);
    }
```

### (十二) 设置默认修改地址

#### #1 默认修改地址-持久层

###### 1.1 规划需要开发的SQL语句

1、检测当前用户想设置默认地址是否存在

```mysql
select *from t_address aid=?;
```

2、在修改用户的收货默认地址前，先将所有的收货地址设置为非默认收货地址。通过数据库t_address查找aid修改默认地址

```mysql
update t_address set is_dafault=0 where uid=?;
```

3、将用户当前选中的记录设置为默认收货地址

```mysql
update t_address set is_default=?,modified_user=?, where aid=?;
```

###### 1.2 接口与抽象方法

在AddressMaper接口中实现。

1、查询当前用户的设置默认地址是否存在

```java
 /**
     * 根据收货地址aid值，查询收货地址详情
     * @param aid 收货地址id
     * @return 匹配的收货地址详情，如果没有匹配的数据，则返回null
     */
    Address findByAid(Integer aid);
```

2、把当前用户的所有的收货地址设置为非默认收货地址

```java
    /**
     * 将某用户的所有收货地址设置为非默认地址
     * @param uid 收货地址归属的用户id
     * @return 受影响的行数
     */
    Integer updateNonDefaultByUid(Integer uid);
```

3、设置当前的默认收货地址

```java
 /**
     * 将指定的收货地址设置为默认地址
     * @param aid 收货地址id
     * @param modifiedUser 修改执行人
     * @param modifiedTime 修改时间
     * @return 受影响的行数
     */
    Integer updateDefaultByAid(
            @Param("aid") Integer aid,
            @Param("modifiedUser") String modifiedUser,
            @Param("modifiedTime") Date modifiedTime);
```

###### 1.3 编写SQL语句

1、实现SQL编写

```mysql
  <!-- 根据收货地址aid值，查询收货地址详情：Address findByAid(Integer aid) -->
<select id="findByAid" resultMap="AddressEntityMap">
      SELECT
            *
       FROM
            t_address
        WHERE
            aid=#{aid}
</select>


    <!-- 将某用户的所有收货地址设置为非默认地址：Integer updateNonDefaultByUid(Integer uid) -->
<update id="updateNonDefaultByUid">
        UPDATE
            t_address
        SET
            is_default=0
        WHERE
            uid=#{uid}
</update>

<!--
将指定的收货地址设置为默认地址：
Integer updateDefaultByAid(
@Param("aid") Integer aid,
@Param("modifiedUser") String modifiedUser,
@Param("modifiedTime") Date modifiedTime) 
-->
    <update id="updateDefaultByAid">
        UPDATE
            t_address
        SET
            is_default=1,
            modified_user=#{modifiedUser},
            modified_time=#{modifiedTime}
        WHERE
            aid=#{aid}
     </update>
```

单元测试；

#### #2 默认修改地址-业务成

###### 2.1 异常规划

1、在执行更新是产生未知的UpdateException异常，已经创建无需重复创建

2、访问的数据是不是当前用户的收货地址数据，非法访问:AccessDeniedException异常

3、收货地址不存在的异常：AddressNotFoundException异常。

###### 2.2 接口与抽象方法

将持久层的三个SQL语句合成一个抽象方法,在业务层接口AddressService中实现。

```java
  /**
     * 设置默认收货地址
     * @param aid 收货地址id
     * @param uid 归属的用户id
     * @param username 当前登录的用户名
     */
void setDefault(Integer aid,Integer uid,String useranme);
```

###### 2.3 实现抽象方法

```java
@Transactional
    @Override
    public void setDefault(Integer aid, Integer uid, String username) {
        // 根据参数aid，调用addressMapper中的findByAid()查询收货地址数据
        Address result = addressMapper.findByAid(aid);
        // 判断查询结果是否为null
        if (result == null) {
            // 是：抛出AddressNotFoundException
            throw new AddressNotFoundException("尝试访问的收货地址数据不存在");
        }

        // 判断查询结果中的uid与参数uid是否不一致(使用equals()判断)
        if (!result.getUid().equals(uid)) {
            // 是：抛出AccessDeniedException
            throw new AccessDeniedException("非法访问的异常");
        }

        // 调用addressMapper的updateNonDefaultByUid()将该用户的所有收货地址全部设置为非默认，并获取返回受影响的行数
        Integer rows = addressMapper.updateNonDefaultByUid(uid);
        // 判断受影响的行数是否小于1(不大于0)
        if (rows < 1) {
            // 是：抛出UpdateException
            throw new UpdateException("设置默认收货地址时出现未知错误[1]");
        }

        // 调用addressMapper的updateDefaultByAid()将指定aid的收货地址设置为默认，并获取返回的受影响的行数
        rows = addressMapper.updateDefaultByAid(aid, username, new Date());
        // 判断受影响的行数是否不为1
        if (rows != 1) {
            // 是：抛出UpdateException
            throw new UpdateException("设置默认收货地址时出现未知错误[2]");
        }
    }

```

单元测试。

#### # 3 默认修改地址-控制层

###### 3.1 处理异常

1、将业务层抛出的异常进行处理

```java
       else if (e instanceof AddressNotFoundException) {
            result.setState(4004);
        } else if (e instanceof AccessDeniedException) {
            result.setState(4005);
        } else if (e instanceof UpdateException) {
            result.setState(5001);
        }
```

###### 3.2 设置请求

```
请求路径：@RequestMapping("{aid}/set_default")
请求参数：Integer aid,HttpSession session
请求类型：Post
响应结果：Void
```

###### 3.3 处理请求

```java
   @RequestMapping("{aid}/set_default")
    public JsonResult<Void> setDefault(@PathVariable("aid") Integer aid, HttpSession session) {
        Integer uid = getUidFromSession(session);
        String username = getUsernameFromSession(session);
        addressService.setDefault(aid, uid, username);
        return new JsonResult<Void>(OK);
    }
```

### (十三) 删除收货地址

#### #1 删除收货地址-持久层

###### 1.1 规划需要的SQL语句

1、在删除之前判断该数据是否存在，判断该条件地址数据的归属是否属于当前用户，已经该发不需要从新开发。

2、执行删除收货地址的信息

```mysql
select *from t_address where aid=?;
```

3、如果用户删除的是默认收货地址，讲剩下的地址中的某一条设置为默认的收货地址；规则可以自己定义：将最新修改的收货地址设置为默认收货地址(modefied_time的字段)；

```mysql
select *from t_address where uid=? order by modified_time desc limite 0,1
```

4、如果用户本身更久只有一条收货地址的数据，删除后，其他操作就可以不用进行。

###### 1.2 设计接口和抽象方法

在AdddressMapper接口中进行抽象方法的设置。

```java
/**
     * 根据收货地址id删除数据
     * @param aid 收货地址idv
     * @return 受影响的行数
     */
    Integer deleteByAid(Integer aid);


  /**
     * 根据用户uid查询当前用户最后一次被修改的收货地址数据
     *
     * @param uid 归属的用户id
     * @return 该用户最后修改的收货地址，如果该用户没有收货地址数据则返回null
     */
    Address findLastModified(Integer uid);
```

###### 1.3 编写SQL语句

在AddressMapper.xml文件中进行映射

```mysql
<!-- 根据收货地址id删除数据：Integer deleteByAid(Integer aid) -->
    <delete id="deleteByAid">
        DELETE FROM
            t_address
        WHERE
            aid=#{aid}
    </delete>

<!-- 查询某用户最后修改的收货地址：Address findLastModified(Integer uid) -->
    <select id="findLastModified" resultMap="AddressEntityMap">
        SELECT
            *
        FROM
            t_address
        WHERE
            uid=#{uid}
        ORDER BY
            modified_time DESC
            LIMIT 0,1
    </select>
```

单元测试。

#### #2 删除收货地址-业务层

###### 2.1 规划异常

1、在执行删除操作的时候可能产生未知的异常导致数据删除不能够删除成功，则抛出DeleteException异常，需要定义和创建

```java
package com.cy.store.service.ex;

/** 删除数据失败的异常 */
public class DeleteException extends ServiceException {
    public DeleteException() {
        super();
    }

    public DeleteException(String message) {
        super(message);
    }

    public DeleteException(String message, Throwable cause) {
        super(message, cause);
    }

    public DeleteException(Throwable cause) {
        super(cause);
    }

    protected DeleteException(String message, Throwable cause, boolean enableSuppression, boolean writableStackTrace) {
        super(message, cause, enableSuppression, writableStackTrace);
    }
}

```

###### 2.2 设计接口和抽象方法

```java
 /**
     * 根据收货地址数据的id，查询收货地址详情
     * @param aid 收货地址id
     * @param uid 归属的用户id
     * @return 匹配的收货地址详情
     */
    Address getByAid(Integer aid, Integer uid);
```

###### 2.3 实现抽象方法

```java
      @Transactional
    @Override
    public void delete(Integer aid, Integer uid, String username) {
        // 根据参数aid，调用findByAid()查询收货地址数据
        Address result = addressMapper.findByAid(aid);
        // 判断查询结果是否为null
        if (result == null) {
            // 是：抛出AddressNotFoundException
            throw new AddressNotFoundException("尝试访问的收货地址数据不存在");
        }

        // 判断查询结果中的uid与参数uid是否不一致(使用equals()判断)
        if (!result.getUid().equals(uid)) {
            // 是：抛出AccessDeniedException：非法访问
            throw new AccessDeniedException("非常访问");
        }

        // 根据参数aid，调用deleteByAid()执行删除
        Integer rows1 = addressMapper.deleteByAid(aid);
        if (rows1 != 1) {
            throw new DeleteException("删除收货地址数据时出现未知错误，请联系系统管理员");
        }

        // 判断查询结果中的isDefault是否为0
        if (result.getIsDefault() == 0) {
            return;
        }

        // 调用持久层的countByUid()统计目前还有多少收货地址
        Integer count = addressMapper.countByUid(uid);
        // 判断目前的收货地址的数量是否为0
        if (count == 0) {
            return;
        }

        // 调用findLastModified()找出用户最近修改的收货地址数据
        Address lastModified = addressMapper.findLastModified(uid);
        // 从以上查询结果中找出aid属性值
        Integer lastModifiedAid = lastModified.getAid();
        // 调用持久层的updateDefaultByAid()方法执行设置默认收货地址，并获取返回的受影响的行数
        Integer rows2 = addressMapper.updateDefaultByAid(lastModifiedAid, username, new Date());
        // 判断受影响的行数是否不为1
        if (rows2 != 1) {
            // 是：抛出UpdateException
            throw new UpdateException("更新收货地址数据时出现未知错误，请联系系统管理员");
        }
    }
```

单元测试。

#### #3 删除收货地址-控制层

###### 3.1 处理异常

```java
else if (e instanceof DeleteException) {
            result.setState(5002);
        } 
```

###### 3.2 设置请求

```
请求路径：@RequestMapping("{aid}/delete")
请求参数：Integer aid,HttpSession session
请求类型：Post
响应结果：Void
```

###### 3.3 处理请求

```java
@RequestMapping("{aid}/delete")
    public JsonResult<Void> delete(@PathVariable("aid") Integer aid, HttpSession session) {
        Integer uid = getUidFromSession(session);
        String username = getUsernameFromSession(session);
        addressService.delete(aid, uid, username);
        return new JsonResult<Void>(OK);
    }
```

### (十四) 商品-热销排行&商品查询

1、在store数据库中创建t_product数据表

```mysql
CREATE TABLE t_product (
  id int(20) NOT NULL COMMENT '商品id',
  category_id int(20) DEFAULT NULL COMMENT '分类id',
  item_type varchar(100) DEFAULT NULL COMMENT '商品系列',
  title varchar(100) DEFAULT NULL COMMENT '商品标题',
  sell_point varchar(150) DEFAULT NULL COMMENT '商品卖点',
  price bigint(20) DEFAULT NULL COMMENT '商品单价',
  num int(10) DEFAULT NULL COMMENT '库存数量',
  image varchar(500) DEFAULT NULL COMMENT '图片路径',
  status int(1) DEFAULT '1' COMMENT '商品状态  1：上架   2：下架   3：删除',
  priority int(10) DEFAULT NULL COMMENT '显示优先级',
  created_time datetime DEFAULT NULL COMMENT '创建时间',
  modified_time datetime DEFAULT NULL COMMENT '最后修改时间',
  created_user varchar(50) DEFAULT NULL COMMENT '创建人',
  modified_user varchar(50) DEFAULT NULL COMMENT '最后修改人',
  PRIMARY KEY (id)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
```

2、在entity中创建实体类

```java
package com.cy.store.entity;
/** 商品数据的实体类 */
@Data
public class Product extends BaseEntity implements Serializable {
    private Integer id;
    private Integer categoryId;
    private String itemType;
    private String title;
    private String sellPoint;
    private Long price;
    private Integer num;
    private String image;
    private Integer status;
    private Integer priority;
    }
```

#### #1 热销排行-持久层

###### 1.1 规划需要编写的SQL语句

查询当前比较热门的商品

```mysql
select *from t_product where stauts=1 order by priority desc limit 0,4;
```

###### 1.2 实现接口和抽象方法

在package com.cy.store.mapper包下创建接口ProductMapper接口并在接口中实现添加热销商品的展示。

```java
package com.cy.store.mapper;
/** 处理商品数据的持久层接口 */
public interface ProductMapper {
    /**
     * 查询热销商品的前四名
     * @return 热销商品前四名的集合
     */
    List<Product> findHotList();
}
```

###### 1.3 编写SQL语句

在mapper包下创建ProductMapper的映射文件ProductMapper.xml编写SQL语句

```mysql
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.cy.store.mapper.ProductMapper">
    <resultMap id="ProductEntityMap" type="com.cy.store.entity.Product">
        <id column="id" property="id"/>
        <result column="category_id" property="categoryId"/>
        <result column="item_type" property="itemType"/>
        <result column="sell_point" property="sellPoint"/>
        <result column="created_user" property="createdUser"/>
        <result column="created_time" property="createdTime"/>
        <result column="modified_user" property="modifiedUser"/>
        <result column="modified_time" property="modifiedTime"/>
    </resultMap>

    <!-- 查询热销商品的前四名：List<Product> findHostList() -->
    <select id="findHotList" resultMap="ProductEntityMap">
        SELECT
            *
        FROM
            t_product
        WHERE
            status=1
        ORDER BY
            priority DESC
            LIMIT 0,4
    </select>
</mapper>
```

#### #2 热销排行-业务层

###### 2.1 异常规划

如果商品数据不存在，应该抛出ProductNotFoundException，需要创建com.cy.store.service.ex.ProductNotFoundException异常。

```java
package com.cy.store.service.ex;

/** 商品数据不存在的异常 */
public class ProductNotFoundException extends ServiceException {
    // Override Methods...
}
```

###### 2.2 设计接口和抽象方法

在业务层IProductService接口中添加findById(Integer id)抽象方法。

```java
/**
 * 根据商品id查询商品详情
 * @param id 商品id
 * @return 匹配的商品详情，如果没有匹配的数据则返回null
 */
Product findById(Integer id);
```

###### 2.3 实现抽象方法

1.在ProductServiceImpl类中，实现接口中的findById(Integer id)抽象方法。

```java
/** 处理商品数据的业务层实现类 */
@Service
public class ProductServiceImpl implements IProductService {
    @Autowired
    private ProductMapper productMapper;

    @Override
    public List<Product> findHotList() {
        List<Product> list = productMapper.findHotList();
        for (Product product : list) {
            product.setPriority(null);
            product.setCreatedUser(null);
            product.setCreatedTime(null);
            product.setModifiedUser(null);
            product.setModifiedTime(null);
        }
        return list;
    }
}
```

单元测试。

#### #3 热销排行-控制层

###### 3.1 处理异常

```java
else if (e instanceof ProductNotFoundException) {
            result.setState(4006);
        }
```

###### 3.2 设置请求

```
请求路径：/host_list
请求参数：
请求类型：GET
响应结果：List<Producet>
```

###### 3.3 处理请求

```java
package com.cy.store.controller;
@RestController
@RequestMapping("products")
public class ProductController extends BaseController {
    @Autowired
    private IProductService productService;

    @RequestMapping("hot_list")
    public JsonResult<List<Product>> getHotList() {
        List<Product> data = productService.findHotList();
        return new JsonResult<List<Product>>(OK, data);
    }
```

### （十五）展示商品详情信息

#### #1 展示商品-持久层

###### 1.1 规划需要的SQL语句

1、通过商品的id去查找商品的详细信息

```mysql
select *from t_product where id=?;
```

###### 1.2 设计接口和抽象方法

在接口productMapper接口中实现抽象方法

```java
/**
     * 根据商品id查询商品详情
     * @param id 商品id
     * @return 匹配的商品详情，如果没有匹配的数据则返回null
     */
    Product findById(Integer id);
```

###### 1.3 编写SQL

在映射配置文件productMapper.xml中编写SQL语句

```mysql
<!-- 根据商品id查询商品详情：Product findById(Integer id) -->
    <select id="findById" resultMap="ProductEntityMap">
        SELECT
            *
        FROM
            t_product
        WHERE
            id=#{id}
    </select>
```

单元测试。

#### #2 展示商品-业务层

###### 2.1 异常规划

如果商品数据不存在，应该抛出ProductNotFoundException，需要创建com.cy.store.service.ex.ProductNotFoundException异常。

```java
package com.cy.store.service.ex;

/** 商品数据不存在的异常 */
public class ProductNotFoundException extends ServiceException {
    // Override Methods...
}
```

###### 2.2 设计接口和抽象方法

```java
 /**
     * 根据商品id查询商品详情
     * @param id 商品id
     * @return 匹配的商品详情，如果没有匹配的数据则返回null
     */
    Product findById(Integer id);
```

###### 2.3 实现接口的方法

```java
 @Override
    public Product findById(Integer id) {
        // 根据参数id调用私有方法执行查询，获取商品数据
        Product product = productMapper.findById(id);
        // 判断查询结果是否为null
        if (product == null) {
            // 是：抛出ProductNotFoundException
            throw new ProductNotFoundException("尝试访问的商品数据不存在");
        }
        // 将查询结果中的部分属性设置为null
        product.setPriority(null);
        product.setCreatedUser(null);
        product.setCreatedTime(null);
        product.setModifiedUser(null);
        product.setModifiedTime(null);
        // 返回查询结果
        return product;
    }
```

单元测试。

#### #3 展示商品-控制层

###### 3.1 处理异常

```java
else if (e instanceof PasswordNotMatchException) {
            result.setState(4002);
        } 
```

###### 3.2 设置请求

```java
请求路径： @GetMapping("{id}/details")
请求参数： Integer id
请求类型： GET
响应结果： Product
```

###### 3.3 处理请求

```java
 @GetMapping("{id}/details")
    public JsonResult<Product> getById(@PathVariable("id") Integer id) {
        // 调用业务对象执行获取数据
        Product data = productService.findById(id);
        // 返回成功和数据
        return new JsonResult<Product>(OK, data);
    }
```

### （十六）加入购物车

1、在数据库store中创建购物车表t_cart

```mysql
CREATE TABLE t_cart (
	cid INT AUTO_INCREMENT COMMENT '购物车数据id',
	uid INT NOT NULL COMMENT '用户id',
	pid INT NOT NULL COMMENT '商品id',
	price BIGINT COMMENT '加入时商品单价',
	num INT COMMENT '商品数量',
	created_user VARCHAR(20) COMMENT '创建人',
	created_time DATETIME COMMENT '创建时间',
	modified_user VARCHAR(20) COMMENT '修改人',
	modified_time DATETIME COMMENT '修改时间',
	PRIMARY KEY (cid)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
```

2、在com.cy.store.entity包下创建t_cart的实体类

```java
/** 购物车数据的实体类 */
public class Cart extends BaseEntity implements Serializable {
    private Integer cid;
    private Integer uid;
    private Integer pid;
    private Long price;
    private Integer num;
}
```

#### #1 购物车-持久层

###### 1.1、规划需要的SQL语句

向购物车表中插入商品数据的SQL语句大致是：

```mysql
insert into t_cart(字段) values(匹配信息); 
```

如果用户曾经将某个商品加入到购物车过，则点击“加入购物车”按钮只会对购物车中相同商品数量做递增操作。

```mysql
update t_cart set num=? where cid=?;
```

关于判断“到底应该插入数据，还是修改数量”，可以通过“查询某用户是否已经添加某商品到购物车”来完成。如果查询到某结果，就表示该用户已经将该商品加入到购物车了，如果查询结果为null，则表示该用户没有添加过该商品。

```mysql
select *from t_cart where pid=? and uid=?;
```

###### 1.2 设计接口和抽象方法

1、创建购物车CartMapper接口，设计抽象方法

```java
   /**
     * 插入购物车数据
     * @param cart 购物车数据
     * @return 受影响的行数
     */
    Integer insert(Cart cart);


/**
     * 修改购物车数据中商品的数量
     * @param cid 购物车数据的id
     * @param num 新的数量
     * @param modifiedUser 修改执行人
     * @param modifiedTime 修改时间
     * @return 受影响的行数
     */
    Integer updateNumByCid(
            @Param("cid") Integer cid,
            @Param("num") Integer num,
            @Param("modifiedUser") String modifiedUser,
            @Param("modifiedTime") Date modifiedTime);


 /**
     * 根据用户id和商品id查询购物车中的数据
     * @param uid 用户id
     * @param pid 商品id
     * @return 匹配的购物车数据，如果该用户的购物车中并没有该商品，则返回null
     */
    Cart findByUidAndPid(
            @Param("uid") Integer uid,
            @Param("pid") Integer pid);
```

###### 1.3 编写SQL

在mpper下创建CartMapper的

```mysql
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.cy.store.mapper.CartMapper">
    <resultMap id="CartEntityMap" type="com.cy.store.entity.Cart">
        <id column="cid" property="cid"/>
        <result column="created_user" property="createdUser"/>
        <result column="created_time" property="createdTime"/>
        <result column="modified_user" property="modifiedUser"/>
        <result column="modified_time" property="modifiedTime"/>
    </resultMap>

    <!-- 插入购物车数据：Integer insert(Cart cart) -->
    <insert id="insert" useGeneratedKeys="true" keyProperty="cid">
        INSERT INTO t_cart (uid, pid, price, num, created_user, created_time, modified_user, modified_time)
        VALUES (#{uid}, #{pid}, #{price}, #{num}, #{createdUser}, #{createdTime}, #{modifiedUser}, #{modifiedTime})
    </insert>

    <!-- 修改购物车数据中商品的数量：
         Integer updateNumByCid(
            @Param("cid") Integer cid,
            @Param("num") Integer num,
            @Param("modifiedUser") String modifiedUser,
            @Param("modifiedTime") Date modifiedTime) -->
    <update id="updateNumByCid">
        UPDATE
            t_cart
        SET
            num=#{num},
            modified_user=#{modifiedUser},
            modified_time=#{modifiedTime}
        WHERE
            cid=#{cid}
    </update>

    <!-- 根据用户id和商品id查询购物车中的数据：
         Cart findByUidAndPid(
            @Param("uid") Integer uid,
            @Param("pid") Integer pid) -->
    <select id="findByUidAndPid" resultMap="CartEntityMap">
        SELECT
            *
        FROM
            t_cart
        WHERE
            uid=#{uid} AND pid=#{pid}
    </select>
</mapper>
```

单元测试。

#### #2 购物车-业务层

###### 2.1 异常规划

在插入数据时，可能抛出InsertException异常；在修改数据时，可能抛出UpdateException异常。如果不限制购物车中的记录的数量，则没有其它异常。

###### 2.2 设计接口和抽象方法

在com.cy.store.service包下创建ICartService接口，并添加抽象方法。

```java
 /**
     * 将商品添加到购物车
     * @param uid 当前登录用户的id
     * @param pid 商品的id
     * @param amount 增加的数量
     * @param username 当前登录的用户名
     */
void addToCart(Integer uid,Integer pid,Integert amount,String username);
```

###### 2.3 实现方法

1.创建com.cy.store.service.impl.CartServiceImpl类，并实现ICartService接口，并在类的定义前添加@Service注解。在类中声明CartMapper持久层对象和IProductService处理商品数据的业务对象，并都添加@Autowired注修饰。

```java
@Override
public void addToCart(Integer uid, Integer pid, Integer amount, String username) {
    // 根据参数pid和uid查询购物车中的数据
    Cart result = cartMapper.findByUidAndPid(uid, pid);
    Integer cid = result.getCid();
    Date now = new Date();
    // 判断查询结果是否为null
    if (result == null) {
        // 是：表示该用户并未将该商品添加到购物车
        // 创建Cart对象
        Cart cart = new Cart();
        // 封装数据：uid,pid,amount
        cart.setUid(uid);
        cart.setPid(pid);
        cart.setNum(amount);
        // 调用productService.findById(pid)查询商品数据，得到商品价格
        Product product = productService.findById(pid);
        // 封装数据：price
        cart.setPrice(product.getPrice());
        // 封装数据：4个日志
        cart.setCreatedUser(username);
        cart.setCreatedTime(now);
        cart.setModifiedUser(username);
        cart.setModifiedTime(now);
        // 调用insert(cart)执行将数据插入到数据表中
        Integer rows = cartMapper.insert(cart);
        if (rows != 1) {
            throw new InsertException("插入商品数据时出现未知错误，请联系系统管理员");
        }
    } else {
        // 否：表示该用户的购物车中已有该商品
        // 从查询结果中获取购物车数据的id
        Integer cid = result.getCid();
        // 从查询结果中取出原数量，与参数amount相加，得到新的数量
        Integer num = result.getNum() + amount;
        // 执行更新数量
        Integer rows = cartMapper.updateNumByCid(cid, num, username, now);
        if (rows != 1) {
            throw new InsertException("修改商品数量时出现未知错误，请联系系统管理员");
        }
    }
}
```

单元测试。

#### #3 购物车-控制层

###### 3.1 处理异常

暂无。

###### 3.2 设置请求

```
请求路径：add_to_cart
请求参数：HttpSession session,Integer pid,Integer amount
请求类型：Post
响应结果：void
```

###### 3.3 处理请求

```java
package com.cy.store.controller;
@RestController
@RequestMapping("carts")
public class CartController extends BaseController {
    @Autowired
    private ICartService cartService;
@RequestMapping("add_to_cart")
    public JsonResult<Void> addToCart(Integer pid, Integer amount, HttpSession session) {
        System.out.println("pid=" + pid);
        System.out.println("amount=" + amount);
        // 从Session中获取uid和username
        Integer uid = getUidFromSession(session);
        String username = getUsernameFromSession(session);
        // 调用业务对象执行添加到购物车
        cartService.addToCart(uid, pid, amount, username);
        // 返回成功
        return new JsonResult<Void>(OK);
    }
}
```

### (十七) 展示购物车列表

#### #1 展示-持久层

###### 1.1 规划需要的SQL语句

显示某用户的购物车列表数据的Sql语句大致是。Mysql的左连接

```mysql
SELECT
	cid,
	uid,
	pid,
	t_cart.price,
	t_cart.num,
	t_product.title,
	t_product.price AS realPrice,
	t_product.image
FROM
	t_cart
	LEFT JOIN t_product ON t_cart.pid = t_product.id 
WHERE
	uid = #{uid}
ORDER BY
	t_cart.created_time DESC
```

###### 1.2 设计接口和实现方法

1.由于涉及多表关联查询，必然没有哪个实体类可以封装此次的查询结果，因此需要创建VO类。创建com.cy.store.vo.CartVO类。

```java
package com.cy.store.vo;
/** 购物车数据的Value Object类 */
@Data
public class CartVO implements Serializable {
    private Integer cid; //购物车中商品的编号 t_cart
    private Integer uid; //当前用户登陆的编号 t_user
    private Integer pid; //商品的编号 t_product
    private Long price; //商品的价格 t_price
    private Integer num; //购物车中商品的数量 t_cart 
    private String title; //购物车中商品的文本介绍 t_product
    private Long realPrice; //购物车中商品的真实价格 t_product
    private String image; //购物车中商品的照片 t_product
}
```

2.在CartMapper接口中添加抽象方法。

```java
/**
 * 查询某用户的购物车数据
 * @param uid 用户id
 * @return 该用户的购物车数据的列表
 */
List<CartVO> findVOByUid(Integer uid);
```

###### 1.3 编写SQL语句

1.在CartMapper.xml文件中添加findVOByUid()方法的映射。

```mysql
<!-- 查询某用户的购物车数据：List<CartVO> findVOByUid(Integer uid) -->
<select id="findVOByUid" resultType="com.cy.store.vo.CartVO">
    SELECT
        cid,
        uid,
        pid,
        t_cart.price,
        t_cart.num,
        t_product.title,
        t_product.price AS realPrice,
        t_product.image
    FROM
        t_cart
        LEFT JOIN t_product ON t_cart.pid = t_product.id 
    WHERE
        uid = #{uid}
    ORDER BY
        t_cart.created_time DESC
</select>
```

单元测试。

#### #2 展示-业务层

###### 2.1 规划异常

暂无

###### 2.2 设计接口有实现方法

在ICartService接口中添加findVOByUid()抽象方法。

```java
/**
 * 查询某用户的购物车数据
 * @param uid 用户id
 * @return 该用户的购物车数据的列表
 */
list<CartVo> getVOByuid(Integer uid);
```

###### 2.3 实现方法

1.在CartServiceImpl类中重写业务接口中的抽象方法。

```java
    @Override
    public List<CartVO> getVOByUid(Integer uid) {
        return cartMapper.findVOByUid(uid);
    }
```

单元测试。

#### #3 展示-控制层

###### 3.1 处理异常

暂无。

###### 3.2 设置请求

```
请求路径：@GetMapping({"", "/"})
请求参数：HttpSession session
请求类型：GET
响应结果：List<CartVO>
```

###### 3.3 处理请求

```java
   @GetMapping({"", "/"})
    public JsonResult<List<CartVO>> getVOByUid(HttpSession session) {
        // 从Session中获取uid
        Integer uid = getUidFromSession(session);
        // 调用业务对象执行查询数据
        List<CartVO> data = cartService.getVOByUid(uid);
        // 返回成功与数据
        return new JsonResult<List<CartVO>>(OK, data);
    }
```

### (十八) 增加商品数量

#### #1 增加数量-持久层

###### 1.1 规划需要的SQL语句

1.首先进行查询需要操作的购物车数据信息。

```mysql
select *from t_cart where cid=?;
```

2.然后计算出新的商品数量值，如果满足更新条件则执行更新操作。此SQL语句无需重复开发。

```mysql
UPDATE t_cart SET num=?, modified_user=?, modified_time=? WHERE cid=?
```

###### 1.2 设计接口和抽象方法

在CartMapper接口中添加抽象方法。

```java
   /**
     * 根据购物车数据id查询购物车数据详情
     * @param cid 购物车数据id
     * @return 匹配的购物车数据详情，如果没有匹配的数据则返回null
     */
    Cart findByCid(Integer cid);
```

###### 1.3 编写SQL语句

```mysql
 <!-- 根据购物车数据id查询购物车数据详情：Cart findByCid(Integer cid) -->
    <select id="findByCid" resultMap="CartEntityMap">
        SELECT
            *
        FROM
            t_cart
        WHERE
            cid = #{cid}
    </select>
```

单元测试。

#### #2 增加数量-业务层

###### 2.1 规划异常

1.如果尝试访问的购物车数据不存在，则抛出CartNotFoundException异常。创建com.cy.store.service.ex.CartNotFoundException类。

```java
/** 购物车数据不存在的异常 */
public class CartNotFoundException extends ServiceException {
	// Override Methods...
}
```

2.如果尝试访问的数据并不是当前登录用户的数据，则抛出AccessDeniedException异常。此异常类无需再次创建。

3.最终执行更新操作时，可能会抛出UpdateException异常。此异常类无需再次创建。

###### 2.2 设计接口和抽象方法

在业务层ICartService接口中添加addNum()抽象方法。

```java
  /**
     * 将购物车中某商品的数量加1
     * @param cid 购物车数量的id
     * @param uid 当前登录的用户的id
     * @param username 当前登录的用户名
     * @return 增加成功后新的数量
     */
    Integer addNum(Integer cid, Integer uid, String username);
```

###### 2.3 实现抽象方法

1.实现addNum()方法中的业务逻辑代码。

```java
@Override
public Integer addNum(Integer cid, Integer uid, String username) {
    // 调用findByCid(cid)根据参数cid查询购物车数据
    Cart result = cartMapper.findByCid(cid);
    // 判断查询结果是否为null
    if (result == null) {
        // 是：抛出CartNotFoundException
        throw new CartNotFoundException("尝试访问的购物车数据不存在");
    }

    // 判断查询结果中的uid与参数uid是否不一致
    if (!result.getUid().equals(uid)) {
        // 是：抛出AccessDeniedException
        throw new AccessDeniedException("非法访问");
    }

    // 可选：检查商品的数量是否大于多少(适用于增加数量)或小于多少(适用于减少数量)
    // 根据查询结果中的原数量增加1得到新的数量num
    Integer num = result.getNum() + 1;

    // 创建当前时间对象，作为modifiedTime
    Date now = new Date();
    // 调用updateNumByCid(cid, num, modifiedUser, modifiedTime)执行修改数量
    Integer rows = cartMapper.updateNumByCid(cid, num, username, now);
    if (rows != 1) {
        throw new InsertException("修改商品数量时出现未知错误，请联系系统管理员");
    }

    // 返回新的数量
    return num;
}
```

单元测试。

#### #3 增加数量-控制层

###### 3.1 处理异常

在BaseController类中添加CartNotFoundException异常类的统一管理。

```java
// ...
else if (e instanceof CartNotFoundException) {
    result.setState(4007);
}
// ...
```

###### 3.2 设置请求

```
请求路径： @RequestMapping("{cid}/num/add")
请求参数： @PathVariable("cid") Integer cid, HttpSession session
请求类型： POST
响应结果： Integer
```

###### 3.3 处理请求

```java
 @RequestMapping("{cid}/num/add")
    public JsonResult<Integer> addNum(@PathVariable("cid") Integer cid, HttpSession session) {
        // 从Session中获取uid和username
        Integer uid = getUidFromSession(session);
        String username = getUsernameFromSession(session);
        // 调用业务对象执行增加数量
        Integer data = cartService.addNum(cid, uid, username);
        // 返回成功
        return new JsonResult<Integer>(OK, data);
    }

```

### (十九) 显示勾选的购物车数据

#### #1 显示勾选-持久层

###### 1.1  规划需要的SQL语句

在“确认订单页”显示的商品信息，应来自前端页面（购物车列表）中勾选的数据，所以显示的信息其实是购物车中的数据。到底需要显示哪些取决于用户的勾选操作，当用户勾选了若干条购物车数据后，这些数据的id应传递到当前“确认订单页”中，该页面根据这些id获取需要显示的数据列表。

所以在持久层需要完成“根据若干个不确定的id值，查询购物车数据表，显示购物车中的数据信息”。则需要执行的SQL语句大致是。

```mysql
SELECT
	cid,
	uid,
	pid,
	t_cart.price,
	t_cart.num,
	t_product.title,
	t_product.price AS realPrice,
	t_product.image
FROM
	t_cart
	LEFT JOIN t_product ON t_cart.pid = t_product.id 
WHERE
	cid IN (?, ?, ?)
ORDER BY
	t_cart.created_time DESC	
```

###### 1.2 设计接口和抽象方法

在CartMapper接口中添加findVOByCids(Integer[] cids)方法。

```java
/**
 * 根据若干个购物车数据id查询详情的列表
 * @param cids 若干个购物车数据id
 * @return 匹配的购物车数据详情的列表
 */
List<CartVO> findVOByCids(Integer[] cids);
```

###### 1.3 编写SQL语句

1.在CartMapper.xml文件中添加SQL语句的映射配置。

```mysql
<!-- 根据若干个购物车数据id查询详情的列表：List<CartVO> findVOByCids(Integer[] cids) -->
<select id="findVOByCids" resultType="com.cy.store.vo.CartVO">
    SELECT
        cid,
        uid,
        pid,
        t_cart.price,
        t_cart.num,
        t_product.title,
        t_product.price AS realPrice,
        t_product.image
    FROM
        t_cart
            LEFT JOIN t_product ON t_cart.pid = t_product.id
    WHERE
        cid IN (
            <foreach collection="array" item="cid" separator=",">
                #{cid}
            </foreach>
        )
    ORDER BY
        t_cart.created_time DESC
</select>
```

单元测试。

#### #2 显示勾选-业务层

###### 2.1 规划异常

暂无。

###### 2.2 设计接口和 抽象方法

在ICartService接口中添加getVOByCids()抽象方法。

```java
/**
 * 根据若干个购物车数据id查询详情的列表
 * @param uid 当前登录的用户的id
 * @param cids 若干个购物车数据id
 * @return 匹配的购物车数据详情的列表
 */
List<CartVO> getVOByCids(Integer uid, Integer[] cids);
```

###### 2.3 实现抽象方法

1.在CartServiceImpl类中重写业务接口中的抽象方法。

```java
@Override
public List<CartVO> getVOByCids(Integer uid, Integer[] cids) {
    List<CartVO> list = cartMapper.findVOByCids(cids);
    /**
    for (CartVO cart : list) {
		if (!cart.getUid().equals(uid)) {
			list.remove(cart);
		}
	}
	*/
    Iterator<CartVO> it = list.iterator();
    while (it.hasNext()) {
        CartVO cart = it.next();
        if (!cart.getUid().equals(uid)) {
            it.remove();
        }
    }
    return list;
}
```

在CartServiceTests测试类中添加getVOByCids()测试方法

#### #3 显示勾选-控制层

###### 3.1 处理异常

暂无。

###### 3.2 设置清求

```
请求路径： @GetMapping("list")
请求参数： Integer[] cids, HttpSession session
请求类型： GET
响应结果： List<CartVO>
```

###### 3.3 处理请求

```java
@GetMapping("list")
    public JsonResult<List<CartVO>> getVOByCids(Integer[] cids, HttpSession session) {
        // 从Session中获取uid
        Integer uid = getUidFromSession(session);
        // 调用业务对象执行查询数据
        List<CartVO> data = cartService.getVOByCids(uid, cids);
        // 返回成功与数据
        return new JsonResult<>(OK, data);
    }
```

### (二十)  创建订单

1、创建数据表

在store数据库中创建t_order和t_order_item数据表。

```mysql
CREATE TABLE t_order (
	oid INT AUTO_INCREMENT COMMENT '订单id',
	uid INT NOT NULL COMMENT '用户id',
	recv_name VARCHAR(20) NOT NULL COMMENT '收货人姓名',
	recv_phone VARCHAR(20) COMMENT '收货人电话',
	recv_province VARCHAR(15) COMMENT '收货人所在省',
	recv_city VARCHAR(15) COMMENT '收货人所在市',
	recv_area VARCHAR(15) COMMENT '收货人所在区',
	recv_address VARCHAR(50) COMMENT '收货详细地址',
	total_price BIGINT COMMENT '总价',
	status INT COMMENT '状态：0-未支付，1-已支付，2-已取消，3-已关闭，4-已完成',
	order_time DATETIME COMMENT '下单时间',
	pay_time DATETIME COMMENT '支付时间',
	created_user VARCHAR(20) COMMENT '创建人',
	created_time DATETIME COMMENT '创建时间',
	modified_user VARCHAR(20) COMMENT '修改人',
	modified_time DATETIME COMMENT '修改时间',
	PRIMARY KEY (oid)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

CREATE TABLE t_order_item (
	id INT AUTO_INCREMENT COMMENT '订单中的商品记录的id',
	oid INT NOT NULL COMMENT '所归属的订单的id',
	pid INT NOT NULL COMMENT '商品的id',
	title VARCHAR(100) NOT NULL COMMENT '商品标题',
	image VARCHAR(500) COMMENT '商品图片',
	price BIGINT COMMENT '商品价格',
	num INT COMMENT '购买数量',
	created_user VARCHAR(20) COMMENT '创建人',
	created_time DATETIME COMMENT '创建时间',
	modified_user VARCHAR(20) COMMENT '修改人',
	modified_time DATETIME COMMENT '修改时间',
	PRIMARY KEY (id)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
```

2、实现订单表的实体类

在com.cy.store.entity包下创建Order实体类。

```java
package com.cy.store.entity;
/** 订单数据的实体类 */
@Data
public class Order extends BaseEntity implements Serializable {
    private Integer oid;
    private Integer uid;
    private String recvName;
    private String recvPhone;
    private String recvProvince;
    private String recvCity;
    private String recvArea;
    private String recvAddress;
    private Long totalPrice;
    private Integer status;
    private Date orderTime;
    private Date payTime;
}    
```

在com.cy.store.entity包下创建OrderItem实体类。

```java
package com.cy.store.entity;
/** 订单中的商品数据 */
@Data
public class OrderItem extends BaseEntity implements Serializable {
    private Integer id;
    private Integer oid;
    private Integer pid;
    private String title;
    private String image;
    private Long price;
    private Integer num;
}    
```

#### #1 订单-持久层

###### 1.1 规划需要的SQL语句

1.插入订单数据的SQL语句大致是。

```mysql
INSERT INTO t_order (
	uid,
	recv_name,
	recv_phone,
	recv_province,
	recv_city,
	recv_area,
	recv_address,
	total_price,
	status,
	order_time,
	pay_time,
	created_user,
	created_time,
	modified_user,
	modified_time 
)
VALUES (
	#对应字段的值列表
)
```

2.插入订单商品数据的SQL语句大致是。

```mysql
INSERT INTO t_order_item ( 
	oid, 
	pid, 
	title, 
	image, 
	price, 
	num, 
	created_user, 
	created_time, 
	modified_user, 
	modified_time 
)
VALUES ( 
	#对应字段的值列表
)
```

###### 1.2 实现接口和抽象方法

在com.cy.store.mapper包下创建OrderMapper接口并在接口中添加抽象方法。

```java
package com.cy.store.mapper;
/** 处理订单及订单商品数据的持久层接口 */
public interface OrderMapper {
    /**
     * 插入订单数据
     * @param order 订单数据
     * @return 受影响的行数
     */
    Integer insertOrder(Order order);

    /**
     * 插入订单商品数据
     * @param orderItem 订单商品数据
     * @return 受影响的行数
     */
    Integer insertOrderItem(OrderItem orderItem);
}
```

###### 1.3 编写SQL

1.在main\resources\mapper文件夹下创建OrderMapper.xml文件，并添加抽象方法的映射。

```mysql
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.cy.store.mapper.OrderMapper">
    <!-- 插入订单数据：Integer insertOrder(Order order) -->
    <insert id="insertOrder" useGeneratedKeys="true" keyProperty="oid">
        INSERT INTO t_order (
            uid, recv_name, recv_phone, recv_province, recv_city, recv_area, recv_address,
            total_price,status, order_time, pay_time, created_user, created_time, modified_user,
            modified_time
        ) VALUES (
            #{uid}, #{recvName}, #{recvPhone}, #{recvProvince}, #{recvCity}, #{recvArea},
            #{recvAddress}, #{totalPrice}, #{status}, #{orderTime}, #{payTime}, #{createdUser},
            #{createdTime}, #{modifiedUser}, #{modifiedTime}
        )
    </insert>

    <!-- 插入订单商品数据：Integer insertOrderItem(OrderItem orderItem) -->
    <insert id="insertOrderItem" useGeneratedKeys="true" keyProperty="id">
        INSERT INTO t_order_item (
            oid, pid, title, image, price, num, created_user,
            created_time, modified_user, modified_time
        ) VALUES (
            #{oid}, #{pid}, #{title}, #{image}, #{price}, #{num}, #{createdUser},
            #{createdTime}, #{modifiedUser}, #{modifiedTime}
        )
    </insert>
</mapper>
```

单元测试。

#### #2 订单-控制层

###### 2.1 异常规划

暂无。

###### 2.2 设计接口和抽象方法

1.由于处理过程中还需要涉及收货地址数据的处理，所以需要先在IAddressService接口中添加getByAid()方法。

```java
/**
 * 根据收货地址数据的id，查询收货地址详情
 * @param aid 收货地址id
 * @param uid 归属的用户id
 * @return 匹配的收货地址详情
 */
Address getByAid(Integer aid, Integer uid);
```

2.在AddressServiceImpl类中实现接口中的getByAid()抽象方法。

```java
@Override
public Address getByAid(Integer aid, Integer uid) {
    // 根据收货地址数据id，查询收货地址详情
    Address address = addressMapper.findByAid(aid);

    if (address == null) {
        throw new AddressNotFoundException("尝试访问的收货地址数据不存在");
    }
    if (!address.getUid().equals(uid)) {
        throw new AccessDeniedException("非法访问");
    }
    address.setProvinceCode(null);
    address.setCityCode(null);
    address.setAreaCode(null);
    address.setCreatedUser(null);
    address.setCreatedTime(null);
    address.setModifiedUser(null);
    address.setModifiedTime(null);
    return address;
}
```

3.在com.cy.store.service包下创建IOrderService业务层接口并添加抽象方法。

```java
package com.cy.store.service;
import com.cy.store.entity.Order;

/** 处理订单和订单数据的业务层接口 */
public interface IOrderService {
    /**
     * 创建订单
     * @param aid 收货地址的id
     * @param cids 即将购买的商品数据在购物车表中的id
     * @param uid 当前登录的用户的id
     * @param username 当前登录的用户名
     * @return 成功创建的订单数据
     */
    Order create(Integer aid, Integer[] cids, Integer uid, String username);
}
```

###### 2.3 实现抽象方法

1.在com.cy.store.service.impl包下创建OrderServiceImpl业务层实现类并实现IOrderService接口；在类定义之前添加@Service注解，在类中添加OrderMapper订单持久层对象、IAddressService处理收货地址对象、ICartService购物车数据对象，并都添加@Autowired注解进行修饰。

```java
package com.cy.store.service.impl;
/** 处理订单和订单数据的业务层实现类 */
@Service
public class OrderServiceImpl implements IOrderService {
    @Autowired
    private OrderMapper orderMapper;
    @Autowired
    private IAddressService addressService;
    @Autowired
    private ICartService cartService;

	// ...
}
```

2.在OrderServiceImpl类中重写父接口中的create()抽象方法。

```java
@Transactional
@Override
public Order create(Integer aid, Integer[] cids, Integer uid, String username) {
    // 创建当前时间对象

    // 根据cids查询所勾选的购物车列表中的数据

    // 计算这些商品的总价

    // 创建订单数据对象
    // 补全数据：uid
    // 查询收货地址数据
    // 补全数据：收货地址相关的6项
    // 补全数据：totalPrice
    // 补全数据：status
    // 补全数据：下单时间
    // 补全数据：日志
    // 插入订单数据

    // 遍历carts，循环插入订单商品数据
    // 创建订单商品数据
    // 补全数据：oid(order.getOid())
    // 补全数据：pid, title, image, price, num
    // 补全数据：4项日志
    // 插入订单商品数据

    // 返回
}
```

3.OrderServiceImpl类中的create()方法具体逻辑代码实现见下。

```java
@Transactional
@Override
public Order create(Integer aid, Integer[] cids, Integer uid, String username) {
    // 创建当前时间对象
    Date now = new Date();

    // 根据cids查询所勾选的购物车列表中的数据
    List<CartVO> carts = cartService.getVOByCids(uid, cids);

    // 计算这些商品的总价
    long totalPrice = 0;
    for (CartVO cart : carts) {
        totalPrice += cart.getRealPrice() * cart.getNum();
    }

    // 创建订单数据对象
    Order order = new Order();
    // 补全数据：uid
    order.setUid(uid);
    // 查询收货地址数据
    Address address = addressService.getByAid(aid, uid);
    // 补全数据：收货地址相关的6项
    order.setRecvName(address.getName());
    order.setRecvPhone(address.getPhone());
    order.setRecvProvince(address.getProvinceName());
    order.setRecvCity(address.getCityName());
    order.setRecvArea(address.getAreaName());
    order.setRecvAddress(address.getAddress());
    // 补全数据：totalPrice
    order.setTotalPrice(totalPrice);
    // 补全数据：status
    order.setStatus(0);
    // 补全数据：下单时间
    order.setOrderTime(now);
    // 补全数据：日志
    order.setCreatedUser(username);
    order.setCreatedTime(now);
    order.setModifiedUser(username);
    order.setModifiedTime(now);
    // 插入订单数据
    Integer rows1 = orderMapper.insertOrder(order);
    if (rows1 != 1) {
        throw new InsertException("插入订单数据时出现未知错误，请联系系统管理员");
    }

    // 遍历carts，循环插入订单商品数据
    for (CartVO cart : carts) {
        // 创建订单商品数据
        OrderItem item = new OrderItem();
        // 补全数据：setOid(order.getOid())
        item.setOid(order.getOid());
        // 补全数据：pid, title, image, price, num
        item.setPid(cart.getPid());
        item.setTitle(cart.getTitle());
        item.setImage(cart.getImage());
        item.setPrice(cart.getRealPrice());
        item.setNum(cart.getNum());
        // 补全数据：4项日志
        item.setCreatedUser(username);
        item.setCreatedTime(now);
        item.setModifiedUser(username);
        item.setModifiedTime(now);
        // 插入订单商品数据
        Integer rows2 = orderMapper.insertOrderItem(item);
        if (rows2 != 1) {
            throw new InsertException("插入订单商品数据时出现未知错误，请联系系统管理员");
        }
    }

    // 返回
    return order;
}
```

4.在com.cy.store.service测试包下创建OrderServiceTests测试类，并添加create()方法进行功能测试。

#### #3 订单-表现层

###### 3.1 处理异常

暂无。

###### 3.2 设置请求

```
请求路径：/orders/create
请求参数：Integer aid, Integer[] cids, HttpSession session
请求类型：POST
响应结果：JsonResult<Order>
```

###### 3.3 处理清求

1.在com.cy.store.controller包下创建OrderController类，并继承自BaseController类；并在类前添加@RequestMapping("orders")注解和@RestController注解；在类中声明IOrderService业务对象，然后添加@Autowired注解修饰；最后在类中添加处理请求的方法。

```java
package com.cy.store.controller;
import com.cy.store.entity.Order;
import com.cy.store.service.IOrderService;
import com.cy.store.util.JsonResult;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import javax.servlet.http.HttpSession;

@RestController
@RequestMapping("orders")
public class OrderController extends BaseController {
    @Autowired
    private IOrderService orderService;

    @RequestMapping("create")
    public JsonResult<Order> create(Integer aid, Integer[] cids, HttpSession session) {
        // 从Session中取出uid和username
        Integer uid = getUidFromSession(session);
        String username = getUsernameFromSession(session);
        // 调用业务对象执行业务
        Order data = orderService.create(aid, cids, uid, username);
        // 返回成功与数据
        return new JsonResult<Order>(OK, data);
    }
}
```

2.完成后启动项目，先登录再访问http://localhost:8081/orders/create?aid=21&cids=4&cids=5&cids=6&cids=7进行测试。
